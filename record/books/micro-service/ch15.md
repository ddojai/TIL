# 15장 쿠버네티스 소개

## 쿠버네티스 개념 소개
- 컨테이너를 실행하는 서버 클러스터(물리 혹은 가상)를 하나의 커다란 논리 서버로 만드는 컨테이너 오케스트레이터
  - 쿠버네티스 API로 객체를 생성해 원하는 상태를 클러스터에 선언하면 쿠버네티스는 지정한 상태와 현재 상태를 지속적으로 비교
  - 차이를 감지하면 현재 상태가 지정한 상태와 일치하도록 조치
- 주요 목적 중 하나는 컨테이너를 배포 및 실행하면서 블루/그린 배포나 카나리아 배포 등의 기술을 사용해 무중단 롤링 업그레이드를 지원
  - 하나 혹은 다수의 컨테이너가 배치된 포드를 클러스터의 가용 노드에 스케줄링 할 수 있다.
  - 실행 중인 컨테이너의 상태를 모니터링 할 수 있도록 컨테이너가 라이브니스 프로브(liveness probe)를 구현한다고 가정
  - 라이브니스 프로브가 비정상 컨테이너를 보고하면 쿠버네티스는 해당 컨테이너를 다시 시작
  - 수평 오토스케일러(horizontal autoscaler)를 사용해 자동이나 수동으로 컨테이너를 스케일링
  - 메모리 및 CPU와 같은 클러스터의 가용 하드웨어 자원을 최적화 하려면 quota(할당량)을 사용해 컨테이너에 필요한 자원양을 지정
  - 컨테이너 그룹이 소비할 수 있는 자원 양에 대한 제한은 네임스페이스 수준에서 지정
  - 네임스페이스는 여러 팀이 쿠버네티스 클러스터를 공유하는 경우 매우 중요
- 다른 주요 목적은 실행 중인 포드와 컨테이너를 위한 서비스 검색을 제공
  - 쿠버네티스의 서비스 객체를 정의하면 요청을 가용 포드로 로드 밸런싱하고 서비스를 검색 가능
  - 서비스 객체를 쿠버네티스 클러스터 외부로 공개할 수도 있지만, 서비스 그룹으로 들어오는 외부 트래픽을 처리하는 데는 인그레스 객체가 더 적합
  - 컨테이너가 레디니스 프로브(readiness probe)를 구현하면 들어오는 요청을 수락할 준비가 도ㅒㅆ는지 쿠버네티스가 안다.
- 내부적으로 클러스터는 각 포드에 IP 주소를 할당하고 포드를 실행하는 노드와 관계 없이 다른 포드에 접근할 수 있게 하는 하나의 플랫 IP 네트워크(flat ip network)를 제공
  - 여러 네트워크 벤더를 지원하고자 쿠버네티스는 Container Network Interface 사양을 준수하는 네트워크 플러그인의 사용을 허용
  - 기본적으로 포드는 격리되어 있지 않으며, 들어오는 모든 요청을 수락
  - 네트워크 정책을 정의할 수 있는 CNI 플러그인을 사용하면 포드에 대한 접근을 제한 가능
  - 에를 들어, 동일한 네임스페이스에 있는 포드에서 오는 트래픽만 허용 가능
- 여러 팀이 하나의 쿠버네티스 클러스터에서 안전하게 작업할 수 있도록 역할 기반 접근 제어(Role-Based Access Control)를 적용 가능
  - 예를 들어, 관리자에게는 클러스터 수준의 리소스에 접근할 수 있는 권한 부여하고, 팀 구성원에게는 팀 소유의 네임스페이스에 생성된 리소스에만 접근할 수 있게 제한할 수 있다.
- 쿠버네티스는 확장성 있고 안전하며 가용성이 높고 탄력적인 컨테이너 실행 플랫폼을 제공

## 쿠버네티스 API 객체 소개
- 쿠버네티스는 여러 유형의 객체나 리소스를 관리할 때 사용하는 API를 정의
- node : 클러스터에 속한 가상 혹은 물리 서버를 의미
- pod : 포드는 쿠버네티스에 배포할 수 있는 컴포넌트의 최소 단위. 하나 혹은 여러 개의 컨테이너를 포함. 일반적으로 포드는 하나의 컨테이너로 구성되지만, 주 컨테이너의 기능 확장을 위해 보조 컨테이너를 사용하기도 한다. 포드에서 사이드카 역할을 하는 보조 컨테이너를 사용해 주 컨테이너를 서비스 메시에 연결.
- deployment : 포드를 배포하고 업그레이드한다. 디플로이먼트 객체는 포드 생성과 모니터링을 레플리카 셋이 담당하도록 위임. 디플로이먼트를 처음 생성했을 때 디플로이먼트 객체가 수행하는 작업은 레플리카 셋 객체를 생성하는 데 그치지만, 디플로이먼트를 롤링 업그레이드할 때 더 큰 역할을 수행한다.
- ReplicaSet : 지정한 수의 포드가 항상 실행되게 한다. 포드가 삭제되면 레플리카 셋이 대체할 포드를 실행한다.
- service : 하나 혹은 여러 개의 포드에 연결하고자 사용하는 안정적인 네트워크 엔드포인트다. 서비스에는 쿠버네티스 클러스터의 내부 네트워크 IP 주소와 DNS 이름이 할당된다. 서비스의 IP 주소는 서비스가 살아 있는 동안 동일하게 유지된다. 서비스로 전송된 요청은 라운드 로빈 방식의 로드 밸런싱을 사용해 사용 가능한 포드 중 하나로 전달된다. 기본적으로 서비스는 클러스터 IP 주소를 사용해 클러스터 내부에만 노출된다. 클러스터에 있는 각 노드의 전용 포트나 쿠버네티스와 연결된 외부 로드 밸런서를 통해 클러스터 외부로 서비스를 노출할 수도 있다. 로드 밸런서를 사용하면 공인 IP나 DNS 이름을 자동으로 프로비저닝할 수 있다. 관리형 쿠버네티스 서비스를 제공하는 클라우드 공급자는 보통 이런 유형의 로드 밸런서를 지원한다.
- ingress : 쿠버네티스 클러스터의 서비스에 대한 HTTP 기반의 외부 접근을 관리한다. 예를 들면 URL 경로나 호스트 이름 등의 HTTP 헤더를 기반으로 트래픽을 클러스터의 서비스로 라우팅한다. 노드 포트나 로드 밸런서를 사용해 서비스를 외부로 노출하는 대신 서비스 앞에 인그레스를 설정하는 게 보통 더 편리하다. 인그레스 객체로 정의한 통신을 실제로 처리하려면 클러스터에서 인그레스 컨트롤러를 실행하고 있어야 한다. 나중에 인그레스 컨트롤러의 예를 소개할 것이다.
- namespace : 쿠버네티스 클러스터의 리소스를 모으고 특정 수준으로 격리하고자 사용한다. 네임스페이스에 속한 리소스는 이름이 고유해야 하지만, 네임스페이스가 다른 경우에는 이름이 같을 수 있다.
- ConfigMap : 컨테이너에서 사용하는 구성을 저장할 때 사용. 실행 중인 컨테이너에 환경 변수나 파일 형식으로 매핑
- Secret : 자격 증명 등의 컨테이너에서 사용하는 민감한 정보를 저장할 떄 사용. 시크릿은 컨피그 맵과 같은 방식으로 컨테이너에 사용할 수 있다. API서버 접근 권한이 있는 사람은 누구나 시크릿의 내용을 볼 수 있으므로 이름이 의미하는 것처럼 안전하진 않다.
- DaemonSet : 클러스터 노드 집합의 각 노드마다 하나의 포드가 실행되게 한다.

## 쿠버네티스 런타임 컴포넌트 소개
- 클러스터는 마스터 노드와 워커 노드로 구성된다.
- 마스터 노드는 클러스터를 관리하며, 워커 노드는 실제 워크로드(예: 클러스터에 배포한 컨테이너)를 실행한다.
- 다음은 컨트롤 플레인을 구성하는, 마스터 노드에서 실행되는 컴포넌트다.
  - api-server : 컨트롤 플레인의 진입점이다. 쿠버네티스의 CLI 도구인 kubectl 등이 사용하는 RESTful API를 제공한다.
  - etcd: 가용성이 높은 키/값 저장소로 클러스터의 모든 데이터를 저장하는 데이터베이스로 사용한다.
  - controller manager: etcd 데이터베이스에 정의된 객체의 현재 상태와 원하는 상태를 비교해 지속적으로 평가하는 여러 컨트롤러를 포함한다.
  - 원하는 상태나 현재 상태가 변경될 때마다 해당 상태 유형을 담당하는 컨트롤러가 원하는 상태와 현재 상태를 맞추는 작업을 수행한다.예를 들어, 포드를 관리하는 replication config는 API 서버를 통해 포드가 추가되거나 실행 중이던 포드가 종료되면 새 포드를 시작한다. node controller는 사용할 수 없는 노드가 생기면 해당 노드에서 실행 중이던 포드를 클러스터의 다른 노드로 다시 스케줄링 한다.
  - scheduler : 새로 생성된 컨테이너를 사용 가능한 메모리, CPU등을 고려해 적절한 노드에 할당한다. affinity 규칙을 사용해 포드가 어떤 노드로 보낼지 결정한다. 예를 들어, 많은 양의 디스크 I/O가 필요한 포드는 빠른 SSD 디스크를 가진 워커 노드에 할당한다. anti-affinity 규칙을 사용해 포드를 분류할 수도 있다. 이를테면 한 디플로이먼트에 속한 포드를 같은 노드에 스케줄링하지 못하도록 안티 어피니티 규칙을 정의할 수 있다.
- 다음은 데이터 플레인을 구성하는, 전체 노드에서 실행되는 컴포넌트다.
  - kubelet: 컨테이너로 실행되지 않고 노드의 운영체제에서 직접 실행되는 노드 에이전트다. 포드 안에서 동작하는 컨테이너를 kubelet이 실행 중인 노드에 할당한다. 노드의 컨테이너 런타임과 API 서버 사이의 통로 역할을 한다.
  - kube-proxy: 쿠버네티스의 서비스 개념을 구현하는 네트워크 프록시다. 적절한 포드로 요청을 전달하며, 서비스를 위한 포드가 둘 이상인 경우에는 보통 라운드 로빈 방식을 사용한다. kube-proxy는 DemonSet 으로 배포 된다.
  - container runtime: 노드에서 컨테이너를 실행하는 소프트웨어다. 일반적으로 도커를 사용하지만 Container Runtime Interface 구현이라면 모두 사용할 수 있다.
  - Kubernetes DNS: 클러스터 내부 네트워크에서 사용하는 DNS 서버다. 서비스와 포드에 DNS 이름을 할당하며, 포드는 이 DNS 서버를 사용해 내부 DNS 이름을 찾도록 구성된다. DNS 서버는 디플로이먼트 객체와 서비스 개체로 배포된다.
  
## 미니큐브를 사용해 쿠버네티스 클러스터 생성
- 미니큐브를 사용해 버추얼박스에서 실행되는 로컬 단일 노드 클러스터를 생성해 보자.

### 미니큐브 프로필 사용
- 여러 개의 쿠버네티스 클러스터를 로컬에서 실행하고자 미니큐브는 프로필이라는 개념을 제공한다.
- 프로필을 지정하지 않으면 이름이 minikube인 기본 프로필을 사용한다.
- 사용 중인 프로필에 관한 정보는 ~/.minikube/profiles 폴더에 있다.

### 쿠버네티스의 CLI 도구인 kubectl 사용
- 클러스터를 구축한 후 클러스터를 관리할 때 일반적으로 사용하는 도구는 kubectl이다.
- API 객체를 관리하려면 kubectl apply 커맨드를 사용. 이 커맨드는 선언적 방식으로 동작하는데, 객체 정의를 쿠버네티스로 전달한 후 적용을 요청. 실제로 무엇을 해야 할지 파악하고 동작하는 건 쿠버네티스에 달려 있다.
- kubectl delete 커맨드는 쿠버네티스에게 일부 API 객체를 삭제하도록 명시적으로 지시.
- 명시적 커맨드인 kubectl create namespace로 네임스페이스 객체를 만들수도 있다.
- 반목적으로 명령형 커맨드를 사용하면 실패한다. 선언형 커맨드인 kubectl apply는 반목적으로 사용해도 실패하지 않으며, 아무런 조치 없이 이전 상태를 유지한 채로 종료
- 사용법을 알고 싶다면 kubectl help 와 kubectl <커맨드> --help 커맨드를 사용해 유용한 정보를 얻을 수 있다.

### kubectl 콘텍스트 사용
- 2개 이상의 쿠버네티스 클러스터를 대상으로 작업하는 경우 예를 들어, 로컬 미니큐브와 온프레미스나 클라우드에 설치된 쿠버네티스 클러스터를 모두 사용해야 하는 경우를 위해 kubectl은 콘텍스트라는 개념을 제공한다. 콘텍스트는 다음과 같은 요소로 구성
  - 쿠버네티스 클러스터
  - 사용자 자격 증명
  - 기본 네임스페이스
- 기본적으로 콘텍스트는 ~/.kube/config 파일에 저장되지만 KUBECONFIG 환경 변수를 사용해 변경할 수 있다.
- 미니큐브로 쿠버네티스 클러스터를 생성하면 미니큐브 프로필과 동일한 이름의 콘텍스트가 생성되며, 이 콘텍스트가 현재 콘텍스트로 설정된다.
- 미니큐브로 클러스터를 생성한 후 실행한 kubectl 커맨드는 미니큐브 클러스터로 전송된다.

### command
``` cmd
# 현재 프로필로 설정
minikube profile my-profile 

# 현재 프로필 확인
minikube config get profile

# 지정한 API 객체의 정보를 보여 준다.
kubectl get all 

# 지정한 API 객체의 자세한 정보를 보여 준다.
kubectl describe svc

# 컨테이너의 로그를 출력한다.
kubectl logs svc

# 사용할 수 있는 콘텍스트 조회
kubectl config get-contexts

# 콘텍스트 전환
kubectl config use-context my-cluster

# 현재 콘텍스트의 기본 네임스페이스 변경
kubectl config set-context $(kubectl config current-context) --namespace=hands-on

# 클러스터가 사용할 미니큐브 프로필 지정
minikube profile handson-spring-boot-cloud

# 클러스터 생성시 자원 지정
minikube start -p handson-spring-boot-cloud \      
--memory=10240 \
--cpus=4 \
--disk-size=30g \
--kubernetes-version=v1.20.0 \
--vm-driver=virtualbox

# 애드온 관리자를 사용해 활성화
minikube addons enables ingress
minikube addons enable metrics-server

# 클러스터는 백그라운드에서 kube-system 네임스페이스에 여러 시스템 포드를 실행해 자체 초기화. 진행 상황 모니터
kubectl get pods --namespace=kube-system

# 네임스페이스 생성
kubectl create namespace first-attempts

# 디플로이먼트 생성
kubectl apply -f kubernetes/first-attempts/nginx-deployment.yaml

# 포드 삭제
kubectl delete pod --selector app=nginx-app

# 네임스페이스 삭제
kubectl delete namespace first-attempts

# curl 커맨드가 있는 도커 이미지 가빈의 작은 컨테이너로 포드 생성. 커맨드 출력 후 터미널로 리디렉션 후 삭제
kubectl run -i --rm --restart=Never curl-client --image=tutum/curl:alpine --command -- curl -s 'http://nginx-app:80'

# 클러스터 일시 정지
minikube stop

# 클러스터 종료
minikube delete --profile handson-spring-boot-cloud
```