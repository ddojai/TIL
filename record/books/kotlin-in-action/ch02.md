# 2. 코틀린 기초

## 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello, World!

- 함수를 최상위 수준으로 정의 가능하다. 꼭 클래스 안에 넣어야 할 필요는 없다.
- 배열도 일반적인 클래스와 마찬가지다. 자바와 달리 배열 처리를 위한 문법이 없다.
- 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다.
  - System.out.println 대신 println이라고 쓴다.

### 2.1.2 함수

#### 문(statement)과 식(expression)의 구분
- 코틀린에서 if는 식이지 문이 아니다.
- 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자식을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않음
- 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
- 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.

#### 식이 본문인 함수
- 본문이 중괄호로 둘라싸인 함수를 블록이 본문인 함수라 함
- 등호와 식으로 이뤄진 함수를 식이 본문인 함수라 함
- 코틀린에서는 식이 본문인 함수가 자주 쓰인다.
- 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.
- 컴파일러가 타입을 분석해 프로그램 구성 요소의 타입을 정해주는 기능을 타입 추론(type inference)이라 부른다.
- 식이 본문인 함수의 반환 타입만 생략 가능
- 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시

### 2.1.3 변수
- 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다.
- 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.