#인사이드 자바스크립트

## ch01. 자바스크립트 기본 개요

### 1.3 자바 스크립트 핵심 개념

#### 1.3.1 객체

- 자바스크립트는 거의 모든 것이 객체
- 기본데이터 타입 boolean, number, string 과 특별한 값인 null, undefined 를 제외한 나머지는 모두 객체
- 기본데이터 타입은 객체처럼 다룰 수 있다. null과 undefined를 제외한 모든 것을 객체로 다룰 수 있다.

#### 1.3.2 함수

- 자바스크립트는 함수도 객체로 취급
- 함수는 일급 객체로 다뤄진다.
  - 일반적인 객체보다 좀 더 많은 기능
  - 자바스크립트에서 함수의 중요성

#### 1.3.3 프로토타입

- 모든 객체는 숨겨진 링크인 프로토타입을 가진다.
- 이 링크는 해당 객체를 생성한 생성자의 프로토 타입 객체를 가리킨다.
- 이 링크로 훨씬 더 다양하게 자신만의 자료구조 작성 가능

#### 1.3.4 실행 컨텍스트와 클로저

- 자신만의 독특한 과정으로 실행 컨텍스트를 만들고 그 안에서 실행이 이루어진다.
- 이 실행 과정에서 자신만의 유효 범위(scope)를 갖는데, 이 과정에서 클로저를 구현가능.

### 1.4 자바스크립트와 객체지향 프로그래밍

- 자바스크립트는 클래스를 지원하지 않지만(ES6이전 내용이라 그런듯) 가능하다.
- 프로토타입 체인과 클로저로 객체지향 프로그래밍에서 제시하는 상속, 캡슐화, 정보 은닉 등의 개념을 소화할 수 있다.

### 1.5 자바스크립트와 함수형 프로그래밍

- 주요 특성인 일급 객체로서의 함수 특성과 클로저를 활용하여 이를 가능케 한다.

### 1.6 자바스크립트의 단점

- 느슨한 타입체크는 자유를 주지만, 컴파일 타임에서 잡지 못하는 오류는 고스란히 런타임 오류로 발견된다.
- 최상위 레벨의 객체들은 모두 전역 객체 안에 위치하는데, 이름 충돌의 위험성이 있다.

## ch02. 자바스크립트 개발 환경

- webstorm 사용

## ch03. 자바스크립트 데이터 타입과 연산자

### 3.1 자바스크립트 기본 타입

- 기본타입은 숫자, 문자열, 불린값을 비롯해 null과 undefined
- 느슨한 타입 체크 언어

#### 3.1.1 숫자 (number)

- 모든 숫자를 64비트 부동 소수점 형태로 저장 (c의 double 타입과 유사)
- 정수나 실수 구분 없이 그 값을 바로 저장할 수 있음
- 5/2는 둘다 실수로 취급되므로 소수 부분까지 출력된 2.5가 결과값
  - 소수 부분을 버린 정수 부분만을 구하려면 Math.floor() 사용

#### 3.1.2 문자열 (string)

- ' ' or " " 로 생성
- c언어의 char 타입과 같이 문자 하나만을 별도로 나타내는 타입은 없음.
- 한번 정의된 문자열은 변하지 않는다.
- 문자 배열처럼 인덱스를 이용해서 접근 가능

#### 3.1.3 불린값(boolean)

- true와 false 값을 나타내는 타입

#### 3.1.4 null과 undefined

- 두 타입 모두 '값이 비어있음'을 나타낸다.
- 기본적으로 값이 할당되지 않은 변수는 undefined 타입이며 값 또한 undefined이다. undefined는 타입이자 값을 나타낸다는 것에 주의 하자.
- 주의할 점은 null 의 typeof 결과가 null이 아니라 object라는 것
- null 타입 변수인지를 확인할 때 typeof 연산자를 사용하면 안 되고, 일치 연산자(===)를 사용해서 확인해야 한다.

### 3.2 자바스크립트 참조 타입(객체 타입)

- 기본 타입을 제외한 모든 값은 객체
- 배열, 함수, 정규표현식 등도 모두 자바스크립트 객체로 표현
- 객체는 단순히 'key:value' 형태의 프로퍼티들을 저장하는 컨테이너로서, cs에서 hash 자료구조와 유사.
- 기본 타입은 하나의 값만을 가지는 데, 참조 타입인 객체는 여러 개의 프로퍼티들을 포함할 수 있으며, 프로퍼티는 기본 타입의 값을 포함하거나, 다른 객체를 가리킬 수도 있다.
- 객체의 프로퍼티는 함수로 포함할 수 있으며, 이러한 프로퍼티를 메서드라고 부른다.

#### 3.2.1 객체 생성

- 클래스라는 개념이 없고, 객체 리터럴이나 생성자 함수 등 별도의 생성 방식이 존재.
  - es6이전 기준
- 객체 생성하는 방법은 크게 세가지
  - 기본 제공 Object() 객체 생성자 함수를 이용
  - 객체 리터럴을 이용
  - 생성자 함수를 이용

##### 3.2.1.1 Object() 생성자 함수 이용

- 객체를 생성할 때, 내장 Object() 생성자 함수를 제공한다.

```javascript
var foo = new Object();
```

##### 3.2.1.2 객체 리터럴 방식 이용

- 리터럴이란 용어의 의미는 표기법. 따라서 객체 리터럴이란 객체를 생성하는 표기법을 의미.
- 객체 리터럴은 중괄호({})를 이용해서 객체를 생성한다. {} 안에 아무것도 적지 않은 경우는 빈 객체가 생성.
- 중괄호 안에 "프로퍼티 이름":"프로퍼티값" 형태로 표기하면, 해당 프로퍼티가 추가된 객체를 생성.
- 프로퍼티 이름은 문자열이나 숫자가 올 수 있다.
- 프로퍼티 값은 자바스크립트의 값을 나타내는 어떤 표현식도 올수 있으며, 이 값이 함수일 경우는 메서드라고 부른다.

```javascript
var foo = {
  name: 'foo',
  age: 30,
};
```

##### 3.2.1.3 생성자 함수 이용

- 함수를 통해서 객체를 생성할 수 있는데 이런 함수를 생성자 함수라고 부름.
- 4장에서 자세히

#### 3.2.2 객체 프로퍼티 읽기/쓰기/갱신

- 객체의 프로퍼티 접근법
  - 대괄호([]) 표기법
  - 마침표(.) 표기법
- 프로퍼티 읽기
  - 대괄호 표기법에서는 접근하려는 프로퍼티 이름을 문자열 형태로 만들어야 한다.
- 대괄호 표기법만을 사용해야 하는 경우
  - 접근하려는 프로퍼티가 표현식이거나 예약어일 경우
- NaN(Not a Number)
  - 수치 연산을 해서 정상적인 값을 얻지 못할 때 출력되는 값. (ex) 1 - 'hello'

#### 3.2.3 for in 문과 객체 프로퍼티 출력

- 객체에 포함된 모든 프로퍼티에 대해 루프를 수행.

#### 3.2.4 객체 프로퍼티 삭제

- delete 연산자를 이용해 즉시 삭제할 수 있다.
- delete 연산자는 객체의 프로퍼티만 삭제할 뿐, 객체 자체를 삭제 못함.

### 3.3 참조 타입의 특성

- 자바스크립트는 기본 타입인 숫자, 문자열, 불린값, null, undefined 5가지를 제외한 모든 값은 객체다.
- 배열이나 함수 또한 객체로 취급된다. 이러한 객체는 자바스크립트에서 참조타입이라고 부른다. 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문.

#### 3.3.1 객체 비교

- 동등 연산자(==)를 사용하여 두 객체를 비교할 때도 객체의 프로퍼티값이 아닌 참조값을 비교한다는 것에 주의해야 한다.
- 기본 타입의 경우 동등 연산자(==)를 이용해서 비교할 때 값을 비교한다.

#### 3.3.2 참조에 의한 함수 호출 방식

- 기본 타입은 call by value 방식으로 호출. 즉, 함수를 호출할 때 인자로 기본 타입의 값을 넘길 경우, 호출된 함수의 매개변수로 복사된 값이 전달된다.
- 객체와 같은 참조 타입의 경우 함수를 호출할 때 call by reference 방식으로 동작. 즉, 함수를 호출할 때 인자로 참조 타입인 객체를 전달할 경우, 객체의 프로퍼티값이 함수의 매개변수로 복사되지 않고, 인자로 넘긴 객체의 참조값이 그대로 함수 내부로 전달된다.

### 3.4 프로토타입

- 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다. 객체지향의 상속 개념과 같이 부모 객체의 프로퍼티를 마치 자신의 것처럼 쓸 수 있는 특징이 있다.
- 자바스크립트에서는 이러한 부모 객체를 프로토타입 객체 라고 부른다.
- ECMAScript 명세서에는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[ Prototype ]]라는 숨겨진 프로퍼티를 가진다고 설명.
- 크롬 브라우저에서는 **proto**가 바로 숨겨진 [[ Prototype ]] 프로퍼티를 의미한다.
- 모든 객체의 프로토타입은 자바스크립트 룰에 따라 객체를 생성시 결정 (4.5 프로토타입 체이닝에서 자세히)
- 객체 리터럴 방식으로 생성된 객체의 경우 Object.prototype 객체가 프로토타입 객체가 된다.

### 3.5 배열

- C나 자바의 배열과 같은 기능을 하는 객체지만 크기를 지정하지 않아도 되고, 어떤 위치에 어느 타입의 데이터를 저장하더라도 에러가 발생하지 않는다.

#### 3.5.1 배열 리터럴

- 자바스크립트에서 새로운 배열을 만드는 데 사용하는 표기법. 대괄호([])를 사용한다.
- 배열 리터럴에서는 각 요소의 값만을 포함한다. 대괄호 내에 접근하고자 하는 원소에 배열 내 위치 인덱스값을 넣어서 접근한다. 인덱스 0부터 시작.

#### 3.5.2 배열의 요소 생성

- 동적으로 배열 원소를 추가 가능.
- 값을 순차적으로 넣을 필요 없이 아무 인덱스 위치에나 값을 동적으로 추가 가능.
- 없는 원소에 접근할 경우 undefined가 출력
- 배열의 요소는 자바스크립트의 모든 데이터 타입의 값을 포함할 수 있다.
- 배열의 크기를 현재 배열의 인덱스 중 가장 큰 값을 기준으로 정함. 값이 할당되지 않은 인덱스의 요소는 undefined 값을 기본으로 가진다.

#### 3.5.3 배열의 length 프로퍼티

- length 프로퍼티는 배열 내에 가장 큰 인덱스에 1을 더한 값.
- 하지만 실제 메모리는 length 크기처럼 할당되지 않는다
- length 프로퍼티를 수정하거나 해서 벗어나게 되는 값은 삭제된다.

##### 3.5.3.1 배열 표준 메서드와 length 프로퍼티

- 배열에서 사용 가능한 다양한 표준 메서드는 length 프로퍼티를 기반으로 동작.
  - ex) push()

#### 3.5.4 배열과 객체

- 배열 역시 객체지만 일반 객체와 차이가 있다.
- 자바스크립트 엔진은 [] 연산자 내에 숫자가 사용될 경우, 해당 숫자를 자동으로 문자열 형태로 바꿔줌.
- typeof 연산 결과 배열과 객체는 모두 object. 자바스크립트도 배열을 객체로 생각한다.
- 배열이 아닌 객체에는 length 프로퍼티 미존재.
- 배열이 아닌 객체에서는 push()와 같은 표준 배열 메서드를 사용할 수 없다. 배열과 객체가 자신의 부모인 프로토타입 객체가 서로 달라서.

#### 3.5.5 배열의 프로퍼티 동적 생성

- 배열도 자바스크립트 객체이므로, 인덱스가 숫자인 배열 원소 이외에도 객체처럼 동적으로 프로퍼티를 추가할 수 있다.
- 배열의 length 프로퍼티는 배열 원소의 가장 큰 인덱스가 변했을 경우에만 변경된다.
- console.dir()로 모든 프로퍼티를 출력해보면 결국 배열도 객체처럼 'key:value' 형태로 배열 원소 및 프로퍼티 등이 있음.

#### 3.5.6 배열의 프로퍼티 열거

- 배열은 for in 문을 사용해서 모든 프로퍼티를 열거할 수 있지만 불필요한 프로퍼티가 출력될 수 있으므로 되도록 for 문을 사용

#### 3.5.7 배열 요소 삭제.

- 배열도 객체이므로, 배열 요소나 프로퍼티 삭제시 delete 연산자 사용 가능.
- delete 연산자는 해당 요소의 값을 undefined로 설정할 뿐 원소 자체를 삭제하지는 않는다.
- 보통 배열에서 요소들을 완전히 삭제할 경우 splice() 배열 메서드를 사용.
  - spice(start, deleteCount, item...)
    - start - 배열에서 시작 위치
    - deleteCount - start에서 지정한 시작 위치부터 삭제할 요소의 수
    - item - 삭제할 위치에 추가할 요소

#### 3.5.8 Array() 생성자 함수

- 배열 리터럴도 결국 자바스크립트 기본 제공 Array() 생성자 함수로 배열 생성 과정을 단순화 시킨 것.
- 호출할 때 인자 개수에 따라 동작이 다르므로 주의
  - 인자가 1개이고, 숫자일 경우 : 호출된 인자를 length로 갖는 빈 배열 생성
  - 그외 : 호출된 인자를 요소로 갖는 배열 생성

#### 3.5.9 유사 배열 객체

- 일반 객체에 length 라는 프로퍼티가 있으면 어떻게 될까?
- length 프로퍼티를 가진 객체를 유사 배열 객체(array-like objects)라고 부른다
- 유사 배열 객체는 4장에서 배울 apply() 메서드를 사용하면 객체지만 표준 배열 메서드를 활용하는 것이 가능.
- 4.4.1 arguments 객체나 jQuery 객체가 유사 배열 객체 형태로 되어 있다.

### 3.6 기본 타입과 표준 메서드

- 기본 타입의 값들에 대해서 객체 형태로 매서드를 호출할 경우 메서드 처리 순간에 객체로 변환된 다음 각 타입별 표준 메서드를 호출. 메서드 호출이 끝나면 기본값으로 복귀.

### 3.7 연산자.

- 연산자 대부분 다른 언어와 유사. 몇 가지 주의해야 할 연산자들에 대해 간단히 살펴보자.

#### 3.7.1 + 연산자

- \+ 연산자는 더하기 연산과 문자열 연결 연산을 수행.
- 두 연산자가 모두 숫자일 경우에만 더하기 연산, 나머지는 문자열 연결

#### 3.7.2 typeof 연산자

- 피연산자의 타입을 문자열 형태로 리턴
- null 과 배열이 'object' 라는 점, 함수는 'function' 이라는 점에 유의
  - 숫자 : 'number'
  - 문자열 : 'string'
  - 불린값 : 'boolean'
  - undefined : 'undefined'
  - 객체, 배열, null : 'object'
  - 함수 : 'function'

#### 3.7.3 == (동등) 연산자와 === (일치) 연산자

- 두 연산자의 차이는 == 연산자는 비교하려는 피연산자의 타입이 다를 경우 타입 변환을 거친 다음 비교.
- == 연산자의 비교는 타입 변환에 따른 잘못된 결과를 얻을 수 있으므로 대부분의 자바스크립트 코딩 가이드에서는 == 연산자로 비교하는 것을 추천하지 않는다.

#### 3.7.4 !! 연산자

- !!의 역활은 피연산자를 불린값으로 변환하는 것.
- 객체는 값이 비어있는 빈 객체라도 true로 변환되는 것을 주의해야 한다.

## ch04. 함수와 프로토 타입 체이닝

- 자바스크립트에서 가장 중요한 개념 1순위는 함수.
- 모듈화 처리나 클로저, 객체 생성 등 자바스크립트의 근간이 되는 많은 기능을 제공.

### 4.1 함수 정의

- 함수 생성하는 3가지 방법
  - 함수 선언문(function statement)
  - 함수 표현식(function expression)
  - Function() 생성자 함수

#### 4.1.1 함수 리터럴

- JS에서는 함수도 일반 객체처럼 값으로 취급
- 함수리터럴을 이용해 함수를 생성 가능. 함수 선언문이나 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성.
- 함수 리터널의 중요 구성 네 가지.
  - function 키워드
  - 함수명 (선택사항, 함수명이 없는 함수를 익명 함수라 한다)
  - 매개변수 리스트
  - 함수 몸체

#### 4.1.2 함수 선언문 방식으로 함수 생성하기

- 함수 선언문 방식은 함수 리터럴 형태와 같다. 주의할 점은 반드시 함수명이 정의되어 있어야 한다는 것.

#### 4.1.3 함수 표현식 방식으로 함수 생성하기

- 함수도 하나의 값으로 취급 됨. (자바스크립트의 함수는 일급 객체라고 한다)
- 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능.
- 함수 리터럴로 함수를 만들고, 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 함수 표현식이라 함.
- 함수 선언문 문법과 거의 유사. 차이점은 함수 표현식 방법에서 함수 이름이 선택 사항이며, 보통 사용하지 않는다는 것.
- 이 책에서는 함수가 할당된 변수를 함수 변수라고 부름.
- 익명 함수를 이용한 함수 표현식 방법 (익명 함수 표현식)
- 함수이름이 포함된 함수 표현식을 기명 함수 표현식 이라 함.
  - 함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근이 불가능함. 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용

##### function statement와 function expression에서의 세미콜론

- 일반적으로 자바스크립트 코드를 작성할 때 함수 선언문 방식으로 선언된 함수의 경우는 함수 끝에 세미콜론(;)을 붙이지 않지만, 함수 표현식 방식의 경우는 세미콜론(;)을 붙이는 것을 권장.

#### 4.1.4 Function() 생성자 함수를 통한 함수 생성하기

- 자바스크립트의 함수도 Function()이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다.
- 함수 선언문이나 함수 표현식 방식도 함수 리터럴 방식으로 함수를 생성하지만, 결국엔, 내부적으로는 Function() 생성자 함수로 함수가 생성.
- 일반적으로 Function() 생성자 함수를 사용한 함수 생성 방법은 자주 사용되지 않음.

#### 4.1.5 함수 호이스팅

- 함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다. 이것을 함수 호이스팅 이라고 부른다.
- 더글러스 크락포드는 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수도 있다고 지적하며, 함수 표현식 사용을 권장하고 있다.
- 함수 호이스팅이 발생하는 원인은 자바스크립트의 변수 생성과 초기화의 작업이 분리돼서 진행되기 때문.

### 4.2 함수 객체 : 함수도 객체다

#### 4.2.1 자바스크립트에서는 함수도 객체다

- 함수의 기본 기능인 코드 실행뿐 아니라, 일반 객체처럼 프로퍼티들을 가질 수 있다.
- 함수를 생성할 때 함수 코드는 함수 객체의 [[Code]] 내부 프로퍼티에 자동으로 저장된다.(ECMAScript 명세서를 참조한 것)

#### 4.2.2 자바스크립트에서 함수는 값으로 취급된다.

- 함수도 일반 객체처럼 취급될 수 있다.
- 자바스크립트 함수는 다음과 같은 동작이 가능.
  - 리터럴에 의해 생성
  - 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
  - 함수의 인자로 전달 가능
  - 함수의 리턴값으로 리턴 가능
  - 동적으로 프로퍼티를 생성 및 할당 가능
- 이와 같은 특징으로 JS에서는 함수를 일급(first class)객체라고 부른다.
- 일급객체라는 말은 앞에서 나열한 기능이 모두 가능한 객체를 지칭한다.
- 이러한 일급 객체의 특성으로 함수형 프로그래밍이 가능

##### 4.2.2.1 변수나 프로퍼티의 값으로 할당

- 함수는 숫자나 문자열처럼 변수나 프로퍼티의 값으로 할당될 수 있다.

##### 4.2.2.2 함수 인자로 전달

- 함수는 다른 함수의 인자로 전달이 가능.

##### 4.2.2.4 리턴값으로 활용

- 함수는 다른 함수의 리턴값으로도 활용할 수 있다.

#### 4.2.3 함수 객체의 기본 프로퍼티

- 일반 객체와는 다르게 추가로 함수 객체만의 표준 프로퍼티가 정의되어 있다.
- ECMA5 스크립트 명세서에는 모든 함수가 length와 prototype 프로퍼티를 가져야 한다고 기술.
- 이외의 name, caller, arguments, `__proto__` 프로퍼티는 ECMA 표준이 아니다.
- name 프로퍼티는 함수의 이름을 나타낸다. 익명 함수는 name 프로퍼티가 빈 문자열이 된다.
- caller 프로퍼티는 자신이 호출한 함수를 나타낸다.
- arguments 프로퍼티는 함수를 호출할 때 전달된 인자값을 나타냄.
- 크롬 브라우저에서는 [[Prototype]]이라는 내부 프로퍼티가 바로 `__proto__` 프로퍼티로 구현되어 있다. 같은 개념이라고 생각하면 됨.
  - 이를 통해 자신의 부모 역할을 하는 프로토타입 객체를 가리킴
- ECMA 표준에서는 함수 객체의 부모 역할을 하는 프로토타입 객체를 Function.prototype 객체라고 명명하고 있으며, 이것 역시 함수 객체라고 정의

##### Note. arguments 객체

- arguments 프로퍼티와 같은 이름으로 ECMA 표준에서는 arguments 객체를 정의하고 있다. 객체는 함수를 호출할 때 호출된 함수의 내부로 인자값과 함께 전달되며, arguments 프로퍼티와 유사하게 함수를 호출할 때 전달 인자값의 정보를 제공.

##### Function.prototype 객체의 프로토타입 객체는?

- ECMAScript 명세서에는 예외적으로 Function.prototype 함수 객체의 부모는 자바스크립트의 모든 객체의 조상격인 Object.prototype 객체라고 설명
- Function.prototype 객체는 모든 함수들의 부모 역할을 하는 프로토타입 객체.
- ECMAScript 명세서에서는 이러한 Function.prototype 객체가 가져야 하는 프로퍼티들을 다음과 같이 기술.
  - constructor 프로퍼티
  - toString() 메서드
  - apply(thisArg, argArray) 메서드
  - call(thisArg, [, arg1 [,arg2, ]]) 메서드
  - bind(thisArg, [.arg1 [.arg2.]]) 메서드

##### 4.2.3.1 length 프로퍼티

- 모든 함수가 가져야 하는 표준 프로퍼티.
- 함수가 정상적으로 실행될 때 기대되는 인자의 개수를 나타낸다.

##### 4.2.3.2 prototype 프로퍼티

- 모든 함수는 개체로서 prototype 프로퍼티를 가지고 있다.
- 함수 객체의 prototype 프로퍼티는 앞서 설명한 모든 객체의 부모를 나타내는 내부 프로퍼티인 [[Prototype]]과 혼동하지 말아야 한다는 것.
- prototype 프로퍼티는 함수가 생성될 때 만들어지며, constructor 프로퍼티 하나만 있는 객체를 가리킨다.
- prototype 프로퍼티가 가리키는 프로토타입 객체의 유일한 constructor 프로퍼티는 자신과 연결된 함수를 가리킨다.
- 자바스크립트에서는 함수를 생성할 때, 함수 자신과 연결된 프로토타입 객체를 동시에 생성하며, 이 둘은 다음 그림처럼 각각 prototype과 constructor라는 프로퍼티로 서로를 참조

##### Note. prototype 프로퍼티와 [[Prototype]] 프로퍼티

- 두 프로퍼티 모두 프로퍼타입 객체를 가리킨다는 공통점이 있지만, 관점에 차이ㅏ 있다.
- [[Prototype]]는 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키는 반면에, 함수 객체가 가지는 prototype 프로퍼티는 이 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킨다.

### 4.3 함수의 다양한 형태

#### 4.3.1 콜백 함수

- 익명 함수의 대표적인 용도가 콜백 함수.

#### 4.3.2 즉시 실행 함수

- 함수를 정의와 동시에 바로 실행하는 함수
- 즉시 실행 함수를 만드는 법은 간단하다.
  - 함수 리터럴을 괄호()로 둘러싼다. 함수 이름이 있든 없든 상관 없다.
  - 함수가 바로 호출될 수 있게 () 괄호 쌍을 추가한다.
  - 괄호 안에 값을 추가해 즉시 실행 함수의 인자로 넘길 수가 있다.
- 같은 함수를 다시 호출할 수 없다.
- 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분 등에 사용할 수 있다.
- jQuery같은 라이브러리 코드를 즉시 실행 함수 내부에 정의해두게 되면, 라이브러리 내의 변수들은 함수 외부에서 접근할 수 없다. 이후 다른 라이브러리들이 동시에 로드가 되더라도 변수 이름 충돌 같은 문제를 방지할 수 있다.

#### 4.3.3 내부 함수

- 함수 내부에 정의된 함수를 내부 함수(inner function)라고 부른다.
- 클로저를 생성하거나 부모 함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용.
- 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다.
  - 이것이 가능한 이유는 자바스크립트의 스코프 체이닝 때문
- 내부 함수는 일반적으로 자신이 정의된 부모 함수 내부에서만 호출이 가능.
- 부모 함수에서 내부 함수를 외부로 리턴하면, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능.
  - 실행이 끝난 부모 함수 스코프의 변수를 참조하는 함수를 클로저 라고 한다.

#### 4.3.4 함수를 리턴하는 함수

- JS에서는 함수도 일급 객체이므로 일반 값처럼 함수 자체를 리턴할 수도 있다.

### 4.4 함수 호출과 this

- JS는 엄격한 문법 체크를 하지 않는 자유로운 특성의 언어로 함수 호출 또한 다른 언어와는 달리 자유롭다.

#### 4.4.1 arguments 객체

- JS에서는 함수를 호출할 때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다.
- 정의된 함수의 인자보다 적게 함수를 호출할 경우 넘겨지지 않은 인자에는 undefined 값이 할당. 더 많게 함수를 호출할 경우 초과된 인자는 무시.
- arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미. 이 객체는 실제 배열이 아닌 유사 배열 객체.
- length 프로퍼티가 있으므로 배열과 유사하게 동작하지만, 배열은 아니므로 배열 메서드를 사용할 경우 에러가 발생. 유사 배열 객체에서 배열 메서드를 사용하는 방법이 있다.

#### 4.4.2 호출 패턴과 this 바인딩

- JS 에서는 arguements 객체 및 this 인자가 함수 내부로 암묵적으로 전달.
- this가 이해하기 어려운 이유는 JS의 함수가 호출되는 방식(호출 패턴)에 따라 this가 다른 객체를 참조하기(this 바인딩) 때문이다.

##### 4.4.2.1 객체의 메서드 호출할 때 this 바인딩

- 객체의 프로퍼티가 함수일 경우 이 함수를 메서드라고 부른다.
- 메서드를 호출할 때, 메서드 내부 코드에서 사용된 this는 해당 메서드를 호출한 객체로 바인딩 된다.

##### 4.4.2.2 함수를 호출할 때 this 바인딩

- JS에서는 함수를 호출하면, 해당 함수 내부 코드에서 사용된 this는 전역 객체에 바인딩된다.
  - 브라우저에서 JS를 실행하는 경우 전역 객체는 window 객체가 된다.
  - Node.js 에서 전역 객체는 global 객체
- JS의 모든 전역 변수는 실제로는 이러한 전역 객체의 프로퍼티들
- 함수 호출에서의 this 바인딩 특성은 내부 함수를 호출했을 경우에도 그대로 적용되므로, 내부 함수에서 this를 이용할 때는 주의
- 내부 함수가 this를 참조하는 JS의 한계를 극복하려면 부모 함수의 this를 내부 함수가 접근 가능한 다른 변수에 저장하는 방법이 사용
  - 관례상 this 값을 저장하는 변수의 이름을 that이라고 짓는다.
- JS 에서는 이와 같은 this 바인딩의 한계를 극복하려고, this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공
- jQuery, underscore.js 등과 같은 JS 라이브러리들은 bind라는 메서드를 통해, 사용자가 원하는 객체를 this에 바인딩 하는 기능을 제공.

##### 4.4.2.3 생성자 함수를 호출할 때 this 바인딩

- 객체지향 언어에서의 생성자 함수의 형식과는 다르게 그 형식이 정해져 있는 것이 아니라, 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.
- 대부분의 JS 스타일 가이드에서는 특정 함수가 생성자 함수로 정의되어 있음을 알리려고 함수 이름의 첫 문자를 대문자로 쓰기를 권하고 있다.
- JS에서 생성자 함수 코드 내부에서 this는 앞서 알아본 메서드와 함수 호출 방식에서의 this 바인딩과는 다르게 동작.
- 생성자 함수로 동작하는 방식 : new 연산자로 JS 함수를 생성자로 호출하면, 다음과 같은 순서로 동작
  1. 빈 객체 생성 및 this 바인딩
  - 생성자 함수가 생성한 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.
  2. this를 통한 프로퍼티 생성
  3. 생성된 객체 리턴
  - 특별하게 리턴문이 없을 경우, this로 바인딩된 새로 생성한 객체가 리턴.
  - 주의 - 생성자 함수가 아닌 일반 함수를 호출할 때 리턴값이 명시되어 있지 않으면 undefined가 리턴
- 객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이
  - 프로토타입 객체(**proto** 프로퍼티)의 차이.
  - 객체 리터럴 방식의 경우는 프로토타입 객체가 Object(실제로는 Object.prototype)
  - 생성자 함수 방식의 경우는 Person(실제로는 Person.prototype)
  - JS 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정.
- 생성자 함수를 new를 붙이지 않고 호출할 경우
  - JS에서 일반 함수와 생성자 함수는 별도의 차이가 없다.
  - 생성자 함수를 new 없이 호출하거나 일반 함수를 new를 붙여서 호출할 경우 코드에서 오류발생 가능. this 바인딩 방식의 차이 때문
- JS 에서는 일반 함수와 생성자 함수의 구분이 별도로 없으므로, 생성자 함수로 사용할 함수는 첫 글자를 대무낮로 표기하는 네이밍 규칙을 권장.
- JS 전문가들은 객체를 생성하는 다음과 같은 별도의 코드 패턴을 사용

```javascript
function A(arg) {
  if (!(this instanceof A)) return new A(arg);
  this.value = arg ? arg : 0;
}
```

##### 4.4.2.4 call과 apply 메서드를 이용한 명시적인 this 바인딩

- JS는 내부적인 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩 시키는 방법도 제공하는데 apply()와 call() 메서드
- call()메서드는 apply() 메서드와는 같고 넘겨받는 인자의 형식만 다르다

#### 4.4.3 함수 리턴

- 자바스크립트 함수는 항상 리턴값을 반환. return 문을 사용하지 않더라도 다음의 규칙으로 항상 리턴값을 전달

##### 4.4.3.1 규칙 1) 일반 함수나 메서드는 리턴값을 지정하지 않을 경우, undefined 값이 리턴된다.

##### 4.4.3.2 규칙 2) 생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴된다.

- 생성자 함수의 리턴값을 새로 생성한 객체가 아니라, 객체 리터럴 방식의 특정 객체로 지정한 경우, 리턴값에서 명시적으로 넘긴 객체나 배열이 리턴된다.
- 생성자 함수의 리턴값으로 넘긴 값이 객체가 아닌 불린, 숫자, 문자열의 경우는 이러한 리턴값을 무시하고 this로 바인딩된 객체가 리턴.

### 4.5 프로토타입 체이닝

#### 4.5.1 프로토타입의 두 가지 의미

- JS는 객체지향 프로그래밍 언어와는 다른 프로토타입 기반의 객체지향프로그래밍을 지원
- JS는 클래스 개념이 없고, 객체 리터럴이나 생성자 함수로 객체를 생성.
- 객체의 부모 객체가 '프로토타입' 객체. 상속 개념과 마찬가지로 자식 객체는 부모 객체가 가진 프로퍼티 접근이나 메서드를 상속받아 호출하는 것이 가능
- 모든 객체는 자신의 부모인 프로토타입 객체를 가리키는 참조 링크 형태의 숨겨진 프로퍼티가 있다. ECMAScript에서는 이러한 링크를 암묵적 프로토타입 링크라고 부르며 이러한 링크는 모든 객체의 [[Prototype]] 프로퍼티에 저장된다.
- 주의 할점은 함수 객체의 prototype 프로퍼티와 객체의 숨은 프로퍼티인 [[Prototype]] 링크를 구분해야 한다.
- JS의 모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모 객체로 설정하는 [[Prototype]] 링크로 연결한다.
- ** proto ** 프로퍼티는 모든 객체에 존재하는 숨겨진 프로퍼티로 객체 자신의 프로토타입 객체를 가리키는 참조 링크 정보다.
- ECMAScript에서는 이것을 [[Prototype]] 프로퍼티로 정하고, 내부적으로만 사용된다고 명시하고 있지만, 크롬이나 파이어폭스 같은 브라우저에서는 ** proto ** 프로퍼티로 명시적으로 제공.
  - 따라서 ** proto ** 프로퍼티나 [[Prototype]] 프로퍼티나 같다고 간주.

#### 4.5.2 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝

- JS에서 객체는 자신의 프로퍼티뿐 아니라, 부모 역활을 하는 프로토타입 객체의 프로퍼티 또한 자신의 것처럼 접근 가능. 이것을 가능케 하는 게 프로토타입 체이닝.
- JS에서 특정 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면 [[Prototype]] 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것을 프로토타입 체이닝이라고 말한다.

#### 4.5.3 생성자 함수로 생성된 객체의 프로토타입 체이닝

- 생성자 함수로 객체를 생성하는 경우는 객체 리터럴 방식과 약간 다른 프로토타입 체이닝이 이뤄진다. 하지만 두 가지 방식 모두 다음과 같은 기본 원칙을 잘 지키고 있다.
  - JS에서 모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체(부모 객체)로 취급한다.

#### 4.5.4 프로토타입 체이닝의 종점

- JS에서 Object.prototype 객체는 프로토타입 체이닝의 종점.
- 객체 리터럴 방식이나 생성자 함수 방식에 상관없이 모든 객체는 Object.prototype 객체가 가진 프로퍼티와 메서드에 접근하고, 서로 공유가 가능.
- 때문에 표준 빌드인 객체인 Object.prototype 에는 모든 객체가 호출 가능한 표준 메서드들이 정의되어 있다.

#### 4.5.5 기본 데이터 타입 확장

- 숫자, 문자열, 배열 등에서 사용되는 표준 메서드들의 경우, 이들의 프로토타입인 Number.prototype, String.prototype, Array.prototype 등에 정의되어 있다.
- 물론 이러한 기본 내장 프로토타입 객체 또한 Object.prototype을 자신의 프로토타입으로 가지고 있어서 프로토타입 체이닝으로 연결된다.
- JS는 표준 빌드인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다.

#### 4.5.6 프로토타입도 자바스크립트 객체다

- 함수 생성시, 자신의 prototype 프로퍼티에 연결되는 프로토타입 객체는 디폴트로 constructor 프로퍼티만을 가진 객체다.
- 프로토타입 객체 역시 자바스크립트 객체 이므로 동적으로 프로퍼티를 추가/삭제하는 것이 가능하다. 이렇게 변경된 프로퍼티는 실시간으로 프로토타입 체이닝에 반영된다.

#### 4.5.7 프로토타입 메서드와 this 바인딩

- 프로토타입 객체는 메서드를 가질 수 있다.
- 객체의 메서드를 호출할 때 this 바인딩 규칙을 그대로 적용하면 된다.

#### 4.5.8 디폴트 프로토타입은 다른 객체로 변경이 가능하다

- 디폴트 프로토타입 객체는 함수가 생성될 때 같이 생성되며, 함수의 prototype 프로퍼티에 연결 된다.
- JS에서는 이렇게 함수를 생성할 때 해당 함수와 연결되는 디폴트 프로토타입 객체를 다른 일반 객체로 변경하는 것이 가능. 이러한 특징을 이용해 객체지향의 상속을 구현.
- 주의 할점은 변경된 시점 이후에 생성된 객체들은 변경된 링크로 연결되지만, 변경 전에 생성된 객체들은 기존 링크를 유지한다.

#### 4.5.9 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다.

- 객체의 특정 프로퍼티를 읽으려고 할 때, 해당 객체에 프로퍼티가 없는 경우 프로토타입 체이닝이 동작한다.
- 객체에 있는 특정 프로퍼티에 값을 쓰려고 한다면 이때는 프로토타입 체이닝이 일어나지 않는다.

## ch05. 실행 컨텍스트와 클로저

### 5.1 실행 컨텍스트 개념

- 콜 스택(call stack)
  - 함수를 호출할 때 해당 함수의 호출 정보가 차곡차곡 쌓여있는 스택 (C 언어를 예로 들면, 함수의 호출 정보 등으로 함수 내 지역 변수 혹은 인자값 등)
  - C 언어의 경우는 함수가 호출될 때마다 해당 함수의 호출 정보가 기존 함수의 호출 정보 위에 스택 형태로 하나씩 쌓인다.
  - 이러한 콜 스택의 호출 정보 등으로 코드의 실행 과정을 추적하여 디버깅과 같은 작업을 수행한다.
  - 보통의 고급 프로그래밍 언어에서 흔히 사용하는 방식으로 자바스크립트 역시 이 범주를 크게 벗어나지 않는다.
- 실행 컨텍스트는 콜 스택에 들어가는 실행 정보 하나와 비슷
- ECMAScript에서는 실행 컨텍스트를 "실행 가능한 코드를 형상화하고 구분하는 추상적인 개념"으로 기술한다.
- 콜스택과 연관하여 정의하면 "실행 가능한 자바스크립트 코드 블록이 실행되는 환경"이라고 할 수 있고, 이 컨텍스트 안에 실행에 필요한 여러가지 정보를 담고 있다.
- 실행 가능한 코드 블록은 대부분의 경우 함수가 된다.
- ECMAScript에서는 실행 컨텍스트가 형성되는 경우를 세 가지로 규정하고 있는데 전역 코드, eval() 함수로 실행되는 코드, 함수 안의 코드를 실행할 경우이다.
- 대부분 프로그래머는 함수로 실행 컨텍스트를 만든다. 이 코드 블록 안에 변수 및 객체, 실행 가능한 코드가 들어있다. 코드가 실행되면 실행 컨텍스트가 생성되고, 실행 컨텍스트는 스택 안에 하나씩 차곡차곡 쌓이고, 제일 위에 위치하는 실행 컨텍스트가 현재 실행되고 있는 컨텍스트다.
- ECMAScript에서는 실행 컨텍스트의 생성을 다음처럼 설명한다.
  - "현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동한다."

### 5.2 실행 컨텍스트 생성 과정

#### 5.2.1 활성 객체 생성

- 실행 컨텍스트가 생성되면 JS 엔진은 해당 컨텍스트에서 실행에 필요한 여러 가지 정보를 담을 객체를 생성하는데, 이를 활성 객체라고 한다.
- 이 객체에 앞으로 사용하게 될 매개변수나 사용자가 정의한 변수 및 객체를 저장하고, 새로 만들어진 컨텍스트로 접근 가능하게 되어 있다.
- 이는 엔진 내부에서 접근할 수 있다는 것이지 사용자가 접근할 수 있다는 것은 아니다.

#### 5.2.2 arguments 객체 생성

- 다음 단계에서는 arguments 객체를 생성한다.
- 앞서 만들어진 활성 객체는 arguments 프로퍼티로 이 arguments 객체를 참조한다.

#### 5.2.3 스코프 정보 생성

- 현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성한다.
- 이 스코프 정보는 현재 실행 중인 실행 컨텍스트 안에서 연결 리스트와 유사한 형식으로 만들어진다.
- 현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 활용한다.
- 이 리스트로 현재 컨텍스트의 변수 뿐 아니라, 상위 실행 컨텍스트의 변수도 접근이 가능하다.
- 이 리스트에서 찾지 못한 변수는 결국 정의되지 않은 변수에 접근하는 것으로 판단하여 에러를 검출한다.
- 이 리스트를 스코프 체인이라고 하는데, [[scope]]프로퍼티로 참조된다.
- 현재 생성된 활성 객체가 스코프 체인의 제일 앞에 추가되며, execute() 함수의 인자나 지역 변수 등에 접근할 수 있다.

#### 5.2.4 변수 생성

- 현재 실행 컨텍스트 내부에서 사용되는 지역 변수의 생성이 이루어진다.
- ECMAScript에서는 생성되는 변수를 저장하는 변수 객체를 언급하는데, 실제적으로 앞서 생성된 활성 객체가 변수 객체로 사용된다.
- 변수 객체 안에서 호출된 인자는 각각의 프로퍼티가 만들어지고 그 값이 할당된다. 만약 값이 넘겨지지 않았다면 undefined가 할당된다.
- 변수나 내부함수를 메모리에 먼저 생성하고, 초기화는 각 변수나 함수에 해당하는 표현식이 실행되기 전까지는 이루어 지지 않는다.
- 표현식의 실행은 변수 객체 생성이 다 이루어진 후 시작된다.

#### 5.2.5 this 바인딩

- 마지막 단계에서는 this 키워드를 사용하는 값이 할당.
- 여기서 this가 참조하는 객체가 없으면 전역 객체를 참조한다.

#### 5.2.6 코드 실행

- 하나의 실행 컨텍스트가 생성되고, 변수 객체가 만들어진 후에, 코드에 있는 여러 가지 표현식 실행이 이루어진다.
- 이렇게 실행되면서 변수의 초기화 및 연산, 또 다른 함수 실행 등이 이루어진다.
- 전역 실행 컨텍스트는 일반적인 실행 컨텍스트와는 약간 다른데, arguments 객체가 없으며, 전역 객체 하나만을 포함하는 스코프 체인이 있다.
- ECMAScript에서 언급된 바에 의하면 실행 컨텍스트가 형성되는 세 가지 중 하나로서 전역 코드가 있는데, 이 전역 코드가 실행될 때 생성되는 컨텍스트가 전역 실행 컨텍스트다.
- 전역 실행 컨텍스트는 변수를 초기화하고 이것의 내부 함수는 일반적인 탑 레벨의 함수로 선언된다.
- 전역 실행 컨텍스트의 변수 객체가 전역 객체로 사용된다. 즉 전역 실행 컨텍스트에서는 변수 객체가 곧 전역 객체이다.
- 따라서 전역적으로 선언된 함수와 변수가 전역 객체의 프로퍼티가 된다.
- 전역 실행 컨텍스트 역시, this를 전역 객체의 참조로 사용한다.

##### Note. 브라우저에서는 최상위 코드가 전역 코드지만, Node.js에서는 다르다.

- Node.js 에서는 최상위 코드가 브라우저와는 달리 전역 코드가 아니다.
- Node.js 에서는 일반적으로 자바스크립트 파일, 이를테면 filename.js가 하나의 모듈로 동작하고 이 파일의 최상위에 변수를 선언해도 그 모듈의 지역 변수가 된다.
- 하지만 var를 사용하지 않을 경우 전역 객체인 global에 들어가고, 이는 전역 객체를 오염시키는 원인이 되므로 주의해야 한다.

### 5.3 스코프 체인

- JS도 다른 언어와 마찬가지로 스코프, 즉 유효 범위가 있다. 유효 범위 안에서 변수와 함수가 존재한다.
- JS는 함수 내의 {,} 블록은, 이를테면 for() {}, if {} 와 같은 구문은 유효 범위가 없다.
- 오직 함수만이 유효 범위의 한 단위가 된다. 이 유효 범위를 나타내는 스코프가 [[scope]] 프로퍼티로 각 함수 객체 내에서 연결 리스트 형식으로 관리되는데, 이를 스코프 체인이라 한다.
- 스코프 체인은 각 실행 컨텍스트의 변수 객체가 구성 요소인 리스트와 같다.
- 각각의 함수는 [[scope]] 프로퍼티로 자신이 생성된 실행 컨텍스트의 스코프 체인을 참조한다.
- 함수가 실행되는 순간 실행 컨텍스트가 만들어지고, 이 실행 컨텍스트는 실행된 함수의 [[scope]] 프로퍼티를 기반으로 새로운 스코프 체인을 만든다.

#### 5.3.1 전역 실행 컨텍스트의 스코프 체인

#### 5.3.2 함수가 호출한 경우 생성되는 실행 컨텍스트의 스코프 체인

- 스코프 체인을 간단히 정리해보자
  - 각 함수 객체는 [[scope]] 프로퍼티로 현재 컨텍스트의 스코프 체인을 참조한다.
  - 한 함수가 실행되면 새로운 실행 컨텍스트가 만들어지는데, 이 새로운 실행 컨텍스트는 자신이 사용할 스코프 체인을 다음과 같은 방법으로 만든다. 현재 실행되는 함수 객체의 [[scope]] 프로퍼티를 복사하고, 새롭게 생성된 변수 객체를 해당 체인의 제일 앞에 추가한다.
  - 요약하면 스코프 체인은 다음과 같이 표현 할 수 있다.
    - 스코프 체인 = 현재 실행 컨텍스트의 변수 객체 + 상위 컨텍스트의 스코프 체인

##### Note.

- 자바스크립트는 스코프 체인을 사용자가 임의로 수정하는 키워드가 있는데, 이것이 with이다.
- with는 eval과 함께, 성능을 높이고자 하는 자바스크립트 프로그래머에게는 사용하지 말아야 할 키워드 이다.
- with 구문은 표현식을 실행하는데, 표현식이 객체이면 객체는 현재 실행 컨텍스트의 스코프 체인에 추가된다(활성화 객체의 바로 앞에). with 구문은 다른 구문(블록 구문일 수도 있음)을 실행하고 실행 컨텍스트의 스코프 체인을 전에 있던 곳에 저장한다.
- 함수 선언은 with 구문의 영향을 받지 않고 함수 객체가 생성되지만, 함수 표현식은 안에서 with 구문과 함께 실행될 수 있다.

### 5.4 클로저

#### 5.4.1 클로저의 개념

- 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수를 클로저라고 한다.
- 클로저로 참조되는 외부 변수를 자유 변수(Free variable) 라고 한다.
- closure 라는 이름은 함수가 자유 변수에 대해 닫혀있다(closed, bound)는 의미인데, 우리말로 의역하면 '자유 변수에 엮여있는 함수'라는 표현이 맞을 듯하다.

##### Note.

- 클로저는 여러 언어에서 차용되고 있는 특성이다.
- 특히 함수를 일급 객체로 취급하는 언어(보통 이를 함수형 언어 라고 한다)에서 주요하게 사용되는 특성이다.
- 대부분의 클로저에서는 스코프 체인에서 뒤쪽에 있는 객체에 자주 접근하므로, 성능을 저하시키는 이유로 지목되기도 한다.
- 클로저를 사용한 코드가 그렇지 않은 코드보다 메모리 부담이 많아진다. 그렇다고 클로저를 쓰지 않는 것은 자바 스크립트의 강력한 기능 하나를 무시하고 사용하는 것과 다름이 없다. 클로저를 영리하게 사용하는 지혜가 필요.

#### 5.4.2 클로저의 활용

##### 5.4.2.1 특정 함수에 사용자가 정의한 객체의 메서드 연결하기

##### 5.4.2.2 함수의 캡슐화

##### 5.4.2.3 setTimeout()에 지정되는 함수의 사용자 정의

#### 5.4.3 클로저를 활용할 때 주의사항

##### 5.4.3.1 클로저의 프로퍼티값이 쓰기 가능하므로 그 값이 여러 번 호출로 항상 변할 수 있음에 유의

##### 5.4.3.2 하나의 클로저가 여러 함수 객체의 스코프 체인에 들어가 있는 경우도 있다.

##### 5.4.3.3 루프 안에서 클로저를 활용할 때는 주의하자.

## ch06. 객체지향 프로그래밍

### 6.1 클래스, 생성자, 메서드

- 자바스크립트는 거의 모든 것이 객체이고, 특히 함수 객체로 많은 것을 구현해낸다.
- 클래스, 생성자, 메서드도 모두 함수로 구현이 가능하다.

#### Note.

- 더글라스 크락포드는 함수를 생성자로 사용하여 프로그래밍하는 것을 추천하지 않는다.
- 그 이유는 생성된 함수는 new로 호출될 수 있을 뿐만 아니라, 직접 호출도 가능하기 때문이다.
- 문제는 new로 호출될 떄와 직접 호출시 this에 바인딩되는 객체가 달라진다는 것.
- 이러한 문제로 일단 생성자로 사용되는 함수는 첫 글자를 대문자로 표기할 것을 권고.

### 6.2 상속

- 자바스크립트 특성 중 객체 프로토타입 체인을 이용하여 상속을 구현 가능.
- 상속의 구현 방식은 크게 두 가지로 구분
  - 클래스 기반 전통적인 상속 방식을 흉내
  - 클래스 개념 없이 객체의 프로토타입으로 상속을 구현하는 방식. 이를 프로토타입을 이용한 상속 이라고 하낟.
- 프로토타입을 이용한 상속은 객체 리터럴을 중심으로 철저히 프로토타입을 이용하여 상속을 구현.

#### 6.2.1 프로토타입을 이용한 상속

- 프로토타입의 특성을 활용해서 상속을 구현하는 것이 프로토타입 기반의 상속

#### 6.2.2 클래스 기반의 상속

### 6.3 캡슐화

- 캡슐화란 기본적으로 관련된 여러 가지 정보를 하나의 틀 안에 담는 것을 의미
- 이를 응용하면 멤버 변수와 메서드가 서로 관련된 정보가 되고 클래스가 이것을 담는 하나의 큰 틀.
- 중요한 것은 정보의 공개 여부로 정보 은닉의 개념

### 6.4 객체지향 프로그래밍 응용 예제

#### 6.4.1 클래스의 기능을 가진 subClass

- 기존 클래스와 같은 기능을 하는 자바스크립트 함수
  - 함수의 프로토타입 체인
  - extend 함수
  - 인스턴스를 생성할 때 생성자 호출

##### 6.4.1.1 subClass 함수 구조
