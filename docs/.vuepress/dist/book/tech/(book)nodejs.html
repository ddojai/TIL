<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Node.js 교과서 | TIL</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="book">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.d0582fc1.css" as="style"><link rel="preload" href="/TIL/assets/js/app.0235138a.js" as="script"><link rel="preload" href="/TIL/assets/js/2.436ac5ee.js" as="script"><link rel="preload" href="/TIL/assets/js/28.4503ac6f.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.29443ebd.js"><link rel="prefetch" href="/TIL/assets/js/11.61ffbab5.js"><link rel="prefetch" href="/TIL/assets/js/12.fd56b06e.js"><link rel="prefetch" href="/TIL/assets/js/13.6d6d801f.js"><link rel="prefetch" href="/TIL/assets/js/14.54ae511d.js"><link rel="prefetch" href="/TIL/assets/js/15.9326f428.js"><link rel="prefetch" href="/TIL/assets/js/16.59b11cce.js"><link rel="prefetch" href="/TIL/assets/js/17.106bf525.js"><link rel="prefetch" href="/TIL/assets/js/18.eaa5b975.js"><link rel="prefetch" href="/TIL/assets/js/19.f755930c.js"><link rel="prefetch" href="/TIL/assets/js/20.ac8b4f01.js"><link rel="prefetch" href="/TIL/assets/js/21.3bd5aaed.js"><link rel="prefetch" href="/TIL/assets/js/22.68cd951c.js"><link rel="prefetch" href="/TIL/assets/js/23.3feb04c0.js"><link rel="prefetch" href="/TIL/assets/js/24.779346bd.js"><link rel="prefetch" href="/TIL/assets/js/25.b59b52ba.js"><link rel="prefetch" href="/TIL/assets/js/26.c0c6c7ad.js"><link rel="prefetch" href="/TIL/assets/js/27.360eaa97.js"><link rel="prefetch" href="/TIL/assets/js/29.64787674.js"><link rel="prefetch" href="/TIL/assets/js/3.401c3d8b.js"><link rel="prefetch" href="/TIL/assets/js/30.cef16292.js"><link rel="prefetch" href="/TIL/assets/js/31.a9247786.js"><link rel="prefetch" href="/TIL/assets/js/32.bcf80982.js"><link rel="prefetch" href="/TIL/assets/js/33.586aad8d.js"><link rel="prefetch" href="/TIL/assets/js/34.0290c947.js"><link rel="prefetch" href="/TIL/assets/js/35.f6fc3347.js"><link rel="prefetch" href="/TIL/assets/js/36.21300ae3.js"><link rel="prefetch" href="/TIL/assets/js/37.5f281d3f.js"><link rel="prefetch" href="/TIL/assets/js/38.8dac9edd.js"><link rel="prefetch" href="/TIL/assets/js/39.3e10d640.js"><link rel="prefetch" href="/TIL/assets/js/4.1d6ef5fb.js"><link rel="prefetch" href="/TIL/assets/js/40.54550932.js"><link rel="prefetch" href="/TIL/assets/js/41.b64c16f9.js"><link rel="prefetch" href="/TIL/assets/js/42.6420dfe0.js"><link rel="prefetch" href="/TIL/assets/js/43.203ba36e.js"><link rel="prefetch" href="/TIL/assets/js/44.927e5bc7.js"><link rel="prefetch" href="/TIL/assets/js/45.60a68f17.js"><link rel="prefetch" href="/TIL/assets/js/46.fe97eba5.js"><link rel="prefetch" href="/TIL/assets/js/47.2a55a663.js"><link rel="prefetch" href="/TIL/assets/js/48.fac9b4eb.js"><link rel="prefetch" href="/TIL/assets/js/49.78bf5894.js"><link rel="prefetch" href="/TIL/assets/js/5.6616a67f.js"><link rel="prefetch" href="/TIL/assets/js/6.b00d925a.js"><link rel="prefetch" href="/TIL/assets/js/7.f88e4318.js"><link rel="prefetch" href="/TIL/assets/js/8.9e344053.js"><link rel="prefetch" href="/TIL/assets/js/9.0eb5db88.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.d0582fc1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><img src="https://avatars.githubusercontent.com/u/2128592?v=4" alt="TIL" class="logo"> <span class="site-name can-hide">TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/TIL/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/TIL/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ENVIRONMENT</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/env/mac.html" class="sidebar-link">mac</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>PHP</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="content__default"><h2 id="_1장-노드-시작하기"><a href="#_1장-노드-시작하기" class="header-anchor">#</a> 1장 노드 시작하기</h2> <h3 id="_1-1-핵심-개념-이해하기"><a href="#_1-1-핵심-개념-이해하기" class="header-anchor">#</a> 1.1 핵심 개념 이해하기</h3> <h4 id="node-js"><a href="#node-js" class="header-anchor">#</a> Node.js</h4> <ul><li>크롬 V8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임</li> <li>이벤트 기반, 논블로킹 I/O 모델을 사용</li> <li>패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계</li></ul> <h4 id="_1-1-1-서버"><a href="#_1-1-1-서버" class="header-anchor">#</a> 1.1.1 서버</h4> <ul><li>노드는 자바스크립트 애플리케이션이 서버로서 기능하기 위한 도구를 제공</li></ul> <h4 id="_1-1-2-자바스크립트-런타임"><a href="#_1-1-2-자바스크립트-런타임" class="header-anchor">#</a> 1.1.2 자바스크립트 런타임</h4> <ul><li>노드는 V8과 libuv 라이브러리 사용</li> <li>libuv 라이브러리는 이벤트 기반, 논블로킹 I/O 모델을 구현</li></ul> <h4 id="_1-1-3-이벤트-기반"><a href="#_1-1-3-이벤트-기반" class="header-anchor">#</a> 1.1.3 이벤트 기반</h4> <ul><li>이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미</li> <li>특정 이벤트가 발생할 때 무엇을 할지 미리 등록 (이벤트 리스너에 콜백 함수 등록)</li> <li>여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단</li> <li>이벤트 루프 : 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복.</li> <li>태스크 큐: 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간. 콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고도 부른다.</li> <li>백그라운드: 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳</li></ul> <h4 id="_1-1-4-논블로킹-i-o"><a href="#_1-1-4-논블로킹-i-o" class="header-anchor">#</a> 1.1.4 논블로킹 I/O</h4> <ul><li>오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 것을 논블로킹 방식이라 한다.</li> <li>싱글 쓰레드라는 한계로 모든 코드가 이득을 볼수 있는 것은 아니다. 현재 노드 프로세스외의 다른 컴퓨터 자원을 사용할 수 있는 I/O 작업이 주로 시간적 이득을 많이 본다.</li></ul> <h4 id="_1-1-5-싱글-스레드"><a href="#_1-1-5-싱글-스레드" class="header-anchor">#</a> 1.1.5 싱글 스레드</h4> <ul><li>프로세스는 운영체제에서 할당하는 작업의 단위. 노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스. 프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.</li> <li>스레드는 프로세스 내에서 실행되는 흐름의 단위. 하나의 프로세스는 스레드를 여러 개 가질 수 있습니다. 스레드들은 부모 프로세스의 자원을 공유합니다.</li></ul> <h3 id="_1-2-서버로서의-노드"><a href="#_1-2-서버로서의-노드" class="header-anchor">#</a> 1.2 서버로서의 노드</h3> <ul><li>노드 서버는 I/O가 많은 작업에 적합합니다. 노드는 libuv 라이브러리를 사용하여 I/O 작업을 논블로킹 방식으로 처리해줍니다. 따라서 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있습니다.</li> <li>하지만 CPU 부하가 큰 작업에는 적합하지 않습니다. 작성하는 코드는 모두 스레드 하나에서 처리되고, 코드가 CPU 연산을 많이 요구하면 블로킹이 발생해 스레드 하나가 감당하기 어렵습니다.</li> <li>싱글 스레드 방식의 프로그래밍은 멀티 스레드 방식보다 상대적으로 쉽습니다. 하지만 싱글 스레드이다 보니 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 합니다. 에러를 제대로 처리하지 못하면 서버 전체가 멈추기 때문입니다.</li> <li>웹 서버가 내장되어 쉽게 접근할 수 있습니다. 하지만 나중에 서버 규모가 커지면 결국 nginx 등의 웹 서버를 노드 서버와 연결해야 합니다.</li> <li>웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있습니다.</li> <li>노드는 생산성이 좋지만 go처럼 비동기에 강점을 보이는 언어나 nginx처럼 정적 파일 제공, 로드 밸런싱에 특화된 서버에 비해서는 속도가 느립니다.</li> <li>json이 자바스크립트 형식이라 노드에서는 쉽게 처리할 수 있습니다.</li></ul> <h3 id="_1-3-서버-외의-노드"><a href="#_1-3-서버-외의-노드" class="header-anchor">#</a> 1.3 서버 외의 노드</h3> <ul><li>노드 기반으로 돌아가는 대표적인 웹 프레임워크로는 Angular, React, Vue, Meteor등이 있습니다.</li> <li>모바일 개발 도구로는 React Native, Ionic Framework를 많이 사용합니다.</li> <li>데스크톱 개발 도구로는 Electron이 대표적입니다.</li></ul> <h2 id="_2장-알아두어야-할-자바스크립트"><a href="#_2장-알아두어야-할-자바스크립트" class="header-anchor">#</a> 2장 알아두어야 할 자바스크립트</h2> <h3 id="_2-1-es2015"><a href="#_2-1-es2015" class="header-anchor">#</a> 2.1 ES2015+</h3> <h4 id="_2-1-1-const-let"><a href="#_2-1-1-const-let" class="header-anchor">#</a> 2.1.1 const, let</h4> <ul><li>var와 달리 블록 스코프를 가짐</li> <li>자바스크립트를 사용할 때 한 번 초기화한 변수에 다른 값을 대입하는 경우는 의외로 적음.</li> <li>기본적으로 변수 선언시에는 const를 사용하고, 다른 값을 대입해야 하는 상황에선 let을 사용</li></ul> <h4 id="_2-1-2-템플릿-문자열"><a href="#_2-1-2-템플릿-문자열" class="header-anchor">#</a> 2.1.2 템플릿 문자열</h4> <ul><li>문자열을 `(백틱) 으로 감싼다</li> <li>문자열 안에 변수를 넣을 수 있다</li></ul> <h4 id="_2-1-3-객체-리터럴"><a href="#_2-1-3-객체-리터럴" class="header-anchor">#</a> 2.1.3 객체 리터럴</h4> <ul><li>객체의 메서드에 함수를 연결할 때 더는 콜론(:)과 function을 붙이지 않아도 됩니다.</li> <li>속성명과 변수명이 겹치는 경우에는 한 번만 쓸 수 있게 되었습니다.</li> <li>객체의 속성명을 동적으로 생성할 수 있습니다.</li></ul> <h4 id="_2-1-4-화살표-함수"><a href="#_2-1-4-화살표-함수" class="header-anchor">#</a> 2.1.4 화살표 함수</h4> <ul><li>화살표 함수라는 새로운 함수가 추가되었으며, 기존의 function() {} 도 그대로 사용할 수 있습니다.</li> <li>기존의 function과 다른 점은 this 바인드 방식</li> <li>기본적으로 화살표 함수를 쓰고, this를 사용해야 하는 경우에는 화살표 함수와 함수 선언문(fuction) 둘 중에 하나를 고른다.</li></ul> <h4 id="_2-1-5-비구조화-할당"><a href="#_2-1-5-비구조화-할당" class="header-anchor">#</a> 2.1.5 비구조화 할당</h4> <ul><li>객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있습니다.</li> <li>코드 줄 수를 줄여줍니다.</li></ul> <h4 id="_2-1-6-프로미스"><a href="#_2-1-6-프로미스" class="header-anchor">#</a> 2.1.6 프로미스</h4> <ul><li>ES2015부터는 자바스크립트와 노드의 API들이 콜백 대신 프로미스 기반으로 재구성됩니다. 그래서 악명 높은 콜백 헬을 극복했다는 평가를 받고 있습니다.</li> <li>코드의 깊이가 더 깊어지지 않고, then 메서드들은 순차적으로 실행됩니다. 콜백에서 매번 따로 처리해야 했던 에러도 마지막 catch에서 한번에 처리할 수 있습니다.</li> <li>하지만 모든 콜백 함수를 대체할 수 있는것은 아니고 메서드가 프로미스 방식을 지원해야 합니다.</li> <li>Promise.all을 활용해서 여러 개의 프로미스를 한번에 실행 가능</li></ul> <h4 id="_2-1-7-async-await"><a href="#_2-1-7-async-await" class="header-anchor">#</a> 2.1.7 async/await</h4> <ul><li>프로미스를 사용한 코드를 한 번 더 깔끔하게 줄여줍니다.</li> <li>for문과 async/await을 같이 써서 Promis.all을 대체할 수도 있습니다. 노드 10 버전부터 지원하는 ES2018 문법입니다.</li></ul> <h3 id="_2-2-프런트엔드-자바스크립트"><a href="#_2-2-프런트엔드-자바스크립트" class="header-anchor">#</a> 2.2 프런트엔드 자바스크립트</h3> <h4 id="_2-2-1-ajax-asynchronous-javascript-and-xml"><a href="#_2-2-1-ajax-asynchronous-javascript-and-xml" class="header-anchor">#</a> 2.2.1 AJAX (Asynchronous Javascript And XML)</h4> <ul><li>비동기적 웹 서비스를 개발하기 위한 기법</li> <li>페이지 이동 없이 서버에 요청을 보내고 응답을 받는 기술</li></ul> <h4 id="_2-2-2-formdata"><a href="#_2-2-2-formdata" class="header-anchor">#</a> 2.2.2 FormData</h4> <ul><li>HTML form 태그의 데이터를 동적으로 제어할 수 있는 기능. 주로 AJAX와 함께 사용됩니다.</li></ul> <h4 id="_2-2-3-encodeurlcomponent-decodeurlcomponent"><a href="#_2-2-3-encodeurlcomponent-decodeurlcomponent" class="header-anchor">#</a> 2.2.3 encodeURLComponent, decodeURLComponent</h4> <ul><li>AJAX 요청시 도메인 주소에 한글이 들어가는 경우 사용</li></ul> <h4 id="_2-2-4-data-attribute와-dataset"><a href="#_2-2-4-data-attribute와-dataset" class="header-anchor">#</a> 2.2.4 data attribute와 dataset</h4> <ul><li>HTML5에서 HTML과 관련된 데이터를 저장하는 공식적인 방법이 data attribute</li></ul> <h2 id="_3장-노드-기능-알아보기"><a href="#_3장-노드-기능-알아보기" class="header-anchor">#</a> 3장 노드 기능 알아보기</h2> <h3 id="_3-1-repl-사용하기"><a href="#_3-1-repl-사용하기" class="header-anchor">#</a> 3.1 REPL 사용하기</h3> <ul><li>노드에서 제공하는 콘솔</li> <li>읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 떄까지 반복(Loop)</li></ul> <h3 id="_3-3-모듈로-만들기"><a href="#_3-3-모듈로-만들기" class="header-anchor">#</a> 3.3 모듈로 만들기</h3> <ul><li>노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와는 다르다.</li> <li>모듈이란 특정한 기능을 하는 함수나 변수들의 집합</li></ul> <h4 id="note-브라우저의-모듈"><a href="#note-브라우저의-모듈" class="header-anchor">#</a> Note 브라우저의 모듈</h4> <ul><li>2015년 자바스크립트에도 import/export라는 모듈 개념이 도입. 하지만 브라우저에는 구현되지 않았는데 크롬 60 버전부터 드디어 브라우저에서도 모듈을 사용할 수 있게 되었다. 앞으로 점차 더 많은 브라우저가 모듈 시스템을 지원할 것으로 보입니다.</li></ul> <h3 id="_3-4-노드-내장-객체-알아보기"><a href="#_3-4-노드-내장-객체-알아보기" class="header-anchor">#</a> 3.4 노드 내장 객체 알아보기</h3> <ul><li>노드에서는 기본적인 내장 객체와 내장 모듈을 제공합니다.</li></ul> <h4 id="_3-4-1-global"><a href="#_3-4-1-global" class="header-anchor">#</a> 3.4.1 global</h4> <ul><li>브라우저의 window 객체와 같은 전역 객체</li> <li>모든 파일에서 접근 가능</li> <li>global도 생략 가능. ex) global.require / global.console</li> <li>내부를 보려면 REPL을 이용</li></ul> <h5 id="note-노드의-window-document-객체"><a href="#note-노드의-window-document-객체" class="header-anchor">#</a> Note 노드의 window, document 객체</h5> <ul><li>노드에는 DOM이나 BOM 없이 window와 document 객체를 사용할 수 없습니다.</li></ul> <h5 id="warning-global-객체의-남용"><a href="#warning-global-객체의-남용" class="header-anchor">#</a> Warning global 객체의 남용</h5> <ul><li>프로그램의 규모가 커질 수록 어떤 파일에서 global 객체에 값을 대입했는지 찾기 힘들어 유지보수가 어려워짐.</li> <li>다른 파일의 값을 사용하고 싶다면 모듈 형식으로 만들어서 명시적으로 값을 불러와 사용하는 것이 좋음.</li></ul> <h4 id="_3-4-2-console"><a href="#_3-4-2-console" class="header-anchor">#</a> 3.4.2 console</h4> <ul><li>console도 노드에서는 window 대신 global 객체 안에 들어 있습니다.</li> <li>cosole.time(레이블): console.timeEnd(레이블)과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정합니다.</li> <li>console.log(내용): 평범한 로그를 콘솔에 표시합니다. console.log(내용, 내용, ...) 처럼 여러 내요을 동시에 표시할 수도 있습니다.</li> <li>console.error(에러 내용): 에러를 콘솔에 표시합니다.</li> <li>console.dir(객체, 옵션): 객체를 콘솔에 표시할 때 사용합니다. 첫 번째 인자로 표시할 객체를 넣고, 두 번째 인자로 옵션을 넣습니다. 옵션의 colors를 true로 하면 콘솔에 색이 추가됩니다. depth는 객체 안의 객체를 몇 단계까지 보여줄지를 결정. 기본값은 2.</li> <li>console.trace(레이블): 에러가 어디서 발생했는지 추적할 수 있게 해줍니다. 보통은 에러 발생 시 에러 위치를 알려주므로 자주 사용하지는 않지만, 위치가 나오지 않는다면 사용할 만합니다.</li></ul> <h4 id="_3-4-3-타이머"><a href="#_3-4-3-타이머" class="header-anchor">#</a> 3.4.3 타이머</h4> <ul><li>타이머 기능을 제공하는 함수는 노드에서 window 대신 global 객체 안에 들어 있습니다.</li> <li>setTimeout(콜백 함수, 밀리초): 주어진 밀리초(1000분의 1초) 이후에 콜백 함수를 실행</li> <li>setInterval(콜백 함수, 밀리초): 주어진 밀리초마다 콜백 함수를 반복 실행</li> <li>setImmediate(콜백 함수): 콜백 함수를 즉시 실행</li> <li>타이머 함수들은 모두 아이디를 반환 합니다. 아이디를 사용하여 타이머를 취소할 수 있습니다.</li> <li>clearTimeout(아이디): setTimeout을 취소</li> <li>clearInterval(아이디): setInterval을 취소</li> <li>clearImmediate(아이디): setImmediate를 취소</li></ul> <h5 id="note-setimmediate-콜백-과-settimeout-콜백-0"><a href="#note-setimmediate-콜백-과-settimeout-콜백-0" class="header-anchor">#</a> Note. setImmediate(콜백)과 setTimeout(콜백, 0)</h5> <ul><li>특수한 경우에 setImmediate는 setTimeout(콜백, 0)보다 먼저 실행됩니다. 파일 시스템 접근, 네트워킹 같은 I/O 작업의 콜백 함수 안에서 타이머를 호출하는 경우입니다. 하지만 항상 먼저 호출 되는 것은 아니다.</li> <li>헷갈리지 않도록 setTimeout(콜백, 0)은 사용하지 않는 것을 권장.</li></ul> <h4 id="_3-4-4-filename-dirname"><a href="#_3-4-4-filename-dirname" class="header-anchor">#</a> 3.4.4 __filename, __dirname</h4> <ul><li>노드에서는 파일 사이에 모듈 관계가 있는 경우가 많아 현재 파일의 경로나 파일명을 알아야 하는 경우가 있습니다.</li> <li>노드는 키워드로 경로에 대한 정보를 제공.</li> <li>__filename : 현재 파일명(경로포함)</li> <li>__dirname : 파일 경로</li> <li>경로가 문자열로 반환되기도 하고, \나 / 같은 경로 구분자 문제도 있어 보통은 이를 해결해주는 path 모듈과 함께 사용.</li></ul> <h4 id="_3-4-5-module-exports"><a href="#_3-4-5-module-exports" class="header-anchor">#</a> 3.4.5 module, exports</h4> <ul><li>module 객체 말고 exports 객체로도 모듈을 만들 수 있습니다.</li> <li>module.exports로 한 번에 대입하는 대신, 각각의 변수를 exports 객체에 하나씩 넣습니다.</li> <li>module.exports와 exports가 같은 객체를 참조.</li></ul> <h5 id="warning-exports-객체-사용-시"><a href="#warning-exports-객체-사용-시" class="header-anchor">#</a> Warning. exports 객체 사용 시</h5> <ul><li>export 객체 사용 시에는 module.exports와의 참조 관계가 깨지지 않도록 주의해야 합니다. module.exports에는 어떤 값이든 대입해도 되지만, exports에는 반드시 객체처럼 속성명과 속성값을 대입해야 합니다. exports에 다른 값을 대입하면 객체의 참조 관계가 끊겨 더 이상 모듈로 기능하지 않습니다.</li> <li>exports를 사용할 때는 객체만 사용할 수 있으므로 func.js와 같이 module.exports에 함수를 대입한 경우에는 exports로 바꿀 수 없습니다.</li> <li>exports와 module.exports에는 참조 관계가 있으므로 한 모듈에 exports 객체와 module.exports를 동시에 사용하지 않는 것이 좋습니다.</li></ul> <h4 id="_3-4-6-process"><a href="#_3-4-6-process" class="header-anchor">#</a> 3.4.6 process</h4> <ul><li>process 객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고 있습니다.</li></ul> <h5 id="_3-4-6-1-process-env"><a href="#_3-4-6-1-process-env" class="header-anchor">#</a> 3.4.6.1 process.env</h5> <ul><li>시스템의 환경 변수</li> <li>서비스의 중요한 키를 저장하는 공간으로도 사용</li> <li>중요한 비밀번호는 process.env의 속성으로 대체</li></ul> <h5 id="_3-4-6-2-process-nexttick-콜백"><a href="#_3-4-6-2-process-nexttick-콜백" class="header-anchor">#</a> 3.4.6.2 process.nextTick(콜백)</h5> <ul><li>이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리하도록 만듭니다.</li> <li>process.nextTick은 setImmediate나 setTimeout 보다 먼저 실행.</li> <li>resolve된 Promise도 nextTick 처럼 다른 콜백들보다 우선시.</li> <li>그래서 마이크로태스크 라고 따로 구분지어 부른다.</li></ul> <h6 id="warning-마이크로태스크의-재귀-호출"><a href="#warning-마이크로태스크의-재귀-호출" class="header-anchor">#</a> Warning. 마이크로태스크의 재귀 호출</h6> <ul><li>Microtask를 재귀 호출하게 되면 이벤트 루프는 다른 콜백 함수보다 Microtask를 우선하여 처리하므로 콜백 함수들이 실행되지 않을 수도 있습니다.</li></ul> <h5 id="_3-4-6-3-process-exit-코드"><a href="#_3-4-6-3-process-exit-코드" class="header-anchor">#</a> 3.4.6.3 process.exit(코드)</h5> <ul><li>실행 중인 노드 프로세스를 종료</li> <li>서버에 이 함수를 사용하면 서버가 멈추므로 서버에는 거의 사용하지 않는다.</li> <li>서버 외의 독립적인 프로그램에서는 수동으로 노드를 멈추게 하기 위해 사용.</li> <li>인자로 코드 번호를 줄 수 있다. 인자를 주지 않거나 0이면 정상종료를 뜻하고, 1을 주면 비정상 종료를 뜻합니다.</li></ul> <h3 id="_3-5-노드-내장-모듈-사용하기"><a href="#_3-5-노드-내장-모듈-사용하기" class="header-anchor">#</a> 3.5 노드 내장 모듈 사용하기</h3> <ul><li>노드는 웹 브라우저에서 사용되는 자바스크립트보다 더 많은 기능을 제공.</li></ul> <h4 id="_3-5-1-os"><a href="#_3-5-1-os" class="header-anchor">#</a> 3.5.1 os</h4> <ul><li>웹 브라우저에 사용되는 자바스크립트는 운영체제의 정보를 가져올 수 없지만, 노드는 os 모듈에 정보가 담겨 있어 정보를 가져올 수 있습니다.</li></ul> <h5 id="note-코어-개수-확인하기"><a href="#note-코어-개수-확인하기" class="header-anchor">#</a> Note. 코어 개수 확인하기</h5> <ul><li>노드는 싱글 스레드라 코어가 몇 개이든 대부분의 경우 코어를 하나밖에 사용하지 않습니다. 하지만 4.5절에 나오는 cluster 모듈을 사용하는 경우 코어 개수에 맞춰서 프로세스를 늘릴 수 있습니다.
이때 cpus() 메서드를 사용합니다.</li></ul> <h4 id="_3-5-2-path"><a href="#_3-5-2-path" class="header-anchor">#</a> 3.5.2 path</h4> <ul><li>폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈</li> <li>운영체제별로 경로 구분자가 다르기 때문에 필요</li> <li>Windows: \로 구분</li> <li>POSIX: /로 구분</li> <li>파일명이나 확장자만 따로 떼어주는 기능도 구현되있음.</li> <li>Windows 에서 POSIX 스타일 path 사용.
<ul><li>ex) path.posix.sep, path.posix.join()</li></ul></li> <li>반대의 경우
<ul><li>ex) path.win32.sep, path.win32.join()</li></ul></li> <li>path 모듈은 앞으로 노드 프로그래밍을 하면서 매우 자주 사용하게 될 모듈 중 하나.</li></ul> <h5 id="note-join과-resolve의-차이"><a href="#note-join과-resolve의-차이" class="header-anchor">#</a> Note. join과 resolve의 차이</h5> <ul><li>path.resolve는 /를 만나면 절대경로로 인식해서 앞의 경로를 무시하고, path.join은 상대경로로 처리</li></ul> <h5 id="note-어떤-때-를-사용하고-어떤-때-를-사용하나요"><a href="#note-어떤-때-를-사용하고-어떤-때-를-사용하나요" class="header-anchor">#</a> Note. 어떤 때 \를 사용하고 어떤 때 \를 사용하나요?</h5> <ul><li>기본적으로 경로는 \ 하나를 사용하여 표시. 하지만 자바스크립트 문자열에서는 \가 특수문자이므로 \를 두 개 붙여 경로를 표시 (Windows 기준)</li> <li>path 모듈은 위와 같은 경우에 발생하는 문제를 알아서 처리. Windows에서 path 모듈이 필요한 이유.</li></ul> <h5 id="note-상대경로와-절대경로"><a href="#note-상대경로와-절대경로" class="header-anchor">#</a> Note. 상대경로와 절대경로</h5> <ul><li>절대경로는 루트 폴더나 노드 프로세스가 실행되는 위치가 기준</li> <li>상대경로는 현재 파일이 기준</li></ul> <h4 id="_3-5-3-url"><a href="#_3-5-3-url" class="header-anchor">#</a> 3.5.3 url</h4> <ul><li>인터넷 주소를 쉽게 조작하도록 도와주는 모듈</li> <li>노드 버전 7에서 추가된 WHATWG(웹 표준을 정하는 단체의 이름) 방식의 url과 예전부터 노드에서 사용하던 방식의 url이 존재</li> <li>query 같은 문자열보다 searchParams가 유용한 이유는 query의 경우 다음 절에 나오는 querystring 모듈을 한 번 더 사용해야 하기 때문입니다.</li></ul> <h4 id="_3-5-4-querystring"><a href="#_3-5-4-querystring" class="header-anchor">#</a> 3.5.4 querystring</h4> <ul><li>WHATWG 방식의 url 대신 기존 노드의 url을 사용할 때 search 부분을 사용하기 쉽게 객체로 만드는 모듈입니다.</li></ul> <h4 id="_3-5-5-crypto"><a href="#_3-5-5-crypto" class="header-anchor">#</a> 3.5.5 crypto</h4> <ul><li>다양한 방식의 암호화를 도와주는 모듈</li> <li>책에서는 웹서비스를 만들 때 사용</li></ul> <h5 id="_3-5-5-1-단방향-암호화"><a href="#_3-5-5-1-단방향-암호화" class="header-anchor">#</a> 3.5.5.1 단방향 암호화</h5> <ul><li>비밀번호는 보통 단방향 암호화 알고리즘 사용</li> <li>복호화할 수 없는 암호화 방식</li> <li>복호화가 필요 없는 경우 ex) 고객의 비밀번호</li> <li>주로 해시 기법을 사용. 어떠한 문자열을 고정된 길이의 다른 문자열로 변경하는 방식.</li> <li>해시 알고리즘 : md5, sha1, sha256, sha512</li> <li>md5와 sha1은 취약점이 발견. 현재는 sha512 사용으로 충분하지만 나중에는 더 강화된 알고리즘이 필요할 수 있음.</li> <li>인코딩 알고리즘 : base64, hex, latin1</li> <li>base64가 결과 문자열이 가장 짧아 많이 사용됨.</li> <li>현재는 주로 pbkdf2나 bcrypt, scrypt라는 알고리즘으로 비밀번호를 암호화하고 있다.</li> <li>노드에서 지원하는 pbkdf2는 간단히 말하면 기존 문자열에 salt라고 불리는 문자열을 붙인 후 해시 알고리즘을 반복해서 적용</li> <li>pbkdf2는 간단하지만 bcrypt나 scrypt보다 취약하므로 나중에 더 나은 보안이 필요하면 scrypt 방식을 사용.</li></ul> <h5 id="_3-5-5-2-양방향-암호화"><a href="#_3-5-5-2-양방향-암호화" class="header-anchor">#</a> 3.5.5.2 양방향 암호화</h5> <ul><li>암호화된 문자열을 복호화 가능.</li> <li>암호화할 때 사용한 키와 같은 키를 사용</li> <li><a href="https://nodejs.org/api/crypto.html" target="_blank" rel="noopener noreferrer">노드 공식 문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h4 id="_3-5-6-util"><a href="#_3-5-6-util" class="header-anchor">#</a> 3.5.6 util</h4> <ul><li>각종 편의 기능을 모아둔 모듈.</li> <li>계속해서 api가 추가되고, deprecated 되어 사라지는 경우도 있다.</li> <li>util.deprecte: 함수가 deprecated 되었음을 알려줌.</li> <li>util.promisify: 콜백 패턴을 프로미스 패턴으로 바꿔줌. async/await 패턴까지 사용 가능</li></ul> <h3 id="_3-6-파일-시스템-접근하기"><a href="#_3-6-파일-시스템-접근하기" class="header-anchor">#</a> 3.6 파일 시스템 접근하기</h3> <ul><li>fs 모듈은 파일 시스템에 접근하는 모듈</li> <li>웹 브라우저에서 자바스크립트를 사용할 때는 파일 다운로드와 파일 시스템 접근이 금지.</li></ul> <h4 id="_3-6-1-동기-메서드와-비동기-메서드"><a href="#_3-6-1-동기-메서드와-비동기-메서드" class="header-anchor">#</a> 3.6.1 동기 메서드와 비동기 메서드</h4> <ul><li>노드는 대부분의 메서드를 비동기 방식으로 처리.</li> <li>fs 모듈은 동기 방식의 메서드를 많이 가지고 있음.</li> <li>비동기 메서드들은 백그라운드에 해당 파일을 읽으라고 요청하고 다음 작업으로 넘어갑니다. 읽기가 완료되면 백그라운드가 다시 메인 스레드에 알림을 주고, 메인스레드는 등록된 콜백 함수를 실행 합니다.</li> <li>이 방식은 수백 개의 I/O 요청이 들어와도 메인 스레드는 백그라운드에 요청 처리를 위임합니다.</li></ul> <h5 id="note-동기와-비동기-블로킹과-논블로킹"><a href="#note-동기와-비동기-블로킹과-논블로킹" class="header-anchor">#</a> Note. 동기와 비동기, 블로킹과 논블로킹</h5> <ul><li>노드에서는 네 용어가 혼용되는데, 용어가 다른만큼 의미도 차이가 있습니다.</li> <li>동기와 비동기 : 함수가 바로 return 되는지 여부</li> <li>블로킹과 논블로킹 : 백그라운드 작업 완료 여부</li> <li>노드에서는 동기-블로킹 방식과 비동기-논블로킹 방식이 대부분. 동기-논블로킹이나 비동기-블로킹은 없다고 보면 됨.</li> <li>동기-블로킹 방식에서는 백그라운드 작업 완료 여부를 계속 확인하며, 호출한 함수가 바로 return되지 않고 백그라운드 작업이 끝나야 return</li> <li>비동기-논블로킹 방식에서는 호출한 함수가 바로 return되어 다음 작업으로 넘어가고, 백그라운드 작업 완료 여부는 신경 쓰지 않고 나중에 백그라운드가 알림을 줄 때 처리.</li></ul> <h4 id="_3-6-2-버퍼와-스트림-이해하기"><a href="#_3-6-2-버퍼와-스트림-이해하기" class="header-anchor">#</a> 3.6.2 버퍼와 스트림 이해하기</h4> <ul><li>파일을 읽거나 쓰는 방식에는 크게 두 가지 방식, 즉 버퍼를 이용하는 방식과 스트림을 이용하는 방식이 있습니다.</li> <li>버퍼링은 영상을 재생할 수 있을 때까지 데이터를 모으는 동작</li> <li>스트리밍은 방속인의 컴퓨터에서 시청자의 컴퓨터로 영상 데이터를 조금씩 전송하는 동작</li> <li>스트리밍하는 과정에서 버퍼링을 할 수도 있음.</li> <li>전송이 너무 느리면 화면을 내보내기까지 최소한의 데이터를 모아야 하고, 영상 데이터가 재생 속도보다 빨리 전송되어도 미리 전송받은 데이터를 저장할 공간이 필요</li> <li>노드의 버퍼와 스트림도 비슷한 개념</li> <li>노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두며, 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 해줌.</li> <li>메모리에 저장된 데이터가 버퍼</li> <li>readFile() 방식의 버퍼가 편리하지만 문제점도 있음.</li> <li>서버같이 몇 명이 이용 할지 모르는 환경에서는 메모리 문제가 발생할 수 있음.</li> <li>또한, 모든 내용을 버퍼에 쓴 후에야 다음 동작으로 넘어가므로 파일 읽기, 압축, 파일 쓰기 등의 조작을 연달아 할 때 매번 전체 용량을 버퍼로 처리해야 다음 단계로 넘어감.</li> <li>그래서 버퍼의 크기를 작게 만들어서 여러 번에 나눠서 보내는 방식이 등장했는데 이를 편리하게 만든 것이 스트림.</li></ul> <h4 id="_3-6-3-기타-fs-메서드"><a href="#_3-6-3-기타-fs-메서드" class="header-anchor">#</a> 3.6.3 기타 fs 메서드</h4> <ul><li>fs.access(경로, 옵션, 콜백) : 폴더나 파일에 접근할 수 있는지 체크</li> <li>fs.mkdir(경로, 콜백): 폴더를 만드는 메서드</li> <li>fs.open(경로, 옵션, 콜백): 파일의 아이디(fd 변수)를 가져오는 메서드</li> <li>fs.rename(기존 경로, 새 경로, 콜백): 파일의 이름을 바꾸는 메서드</li> <li>fs.readdir(경로, 콜백): 폴더 안의 내용물 확인</li> <li>fs.unlink(경로, 콜백): 파일을 지울 수 있다.</li> <li>fs.rmdir(경로, 콜백): 폴더를 지울 수 있다.</li></ul> <h5 id="note-fs-프로미스"><a href="#note-fs-프로미스" class="header-anchor">#</a> Note. fs 프로미스</h5> <ul><li>노드 10 버전에 fs 모듈을 프로미스 형식으로 사용하는 방법이 추가. 다음과 같이 fs 모듈로부터 promises 객체를 불러와 사용.</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fsPromises <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>promises<span class="token punctuation">;</span>
</code></pre></div><ul><li>하지만 아직 실험적인 기능 (3.9절에 fs 프로미스에 대해 설명해놓은 사이트 링크)</li></ul> <h3 id="_3-7-이벤트-이해하기"><a href="#_3-7-이벤트-이해하기" class="header-anchor">#</a> 3.7 이벤트 이해하기</h3> <ul><li>스트림을 배울 때 on을 사용했습니다.</li> <li>직접 이벤트를 만들 수 있습니다.</li></ul> <h3 id="_3-8-예외-처리하기"><a href="#_3-8-예외-처리하기" class="header-anchor">#</a> 3.8 예외 처리하기</h3> <ul><li>예외란 보통 처리하지 못한 에러를 가리킵니다.</li> <li>멀티 스레드 프로그램에선 스레드 하나가 멈추면 다른 스레드가 대신합니다. 노드는 스레드가 하나.</li> <li>throw를 하면 노드 프로세스가 멈추므로 try catch문으로 throw한 에러를 잡아주어야 한다.</li> <li>노드 공식 문서에서는 uncaughtException 이벤트를 최후의 수단으로 사용하라고 말한다.</li> <li>노드는 uncaughtException 이벤트 발생 후 다음 동작이 제대로 동작하는지를 보증하지 않습니다. 따라서 단순히 에러 내용을 기록하는 정도로 사용하고 process.exit()로 프로세스를 종료하는 것이 좋습니다.</li> <li>서버 운영은 에러와의 싸움. 에러발생 시 철저히 로깅 하고, 주기적으로 로그를 확인하면서 보완해 나간다.</li></ul> <h3 id="_3-9-함께-보면-좋은-자료"><a href="#_3-9-함께-보면-좋은-자료" class="header-anchor">#</a> 3.9 함께 보면 좋은 자료</h3> <ul><li>노드 공식 문서</li> <li>uncaughtException</li> <li>fs 프로미스</li></ul> <h2 id="_4장-http-모듈로-웹-서버-만들기"><a href="#_4장-http-모듈로-웹-서버-만들기" class="header-anchor">#</a> 4장. http 모듈로 웹 서버 만들기</h2> <h3 id="_4-1-요청과-응답-이해하기"><a href="#_4-1-요청과-응답-이해하기" class="header-anchor">#</a> 4.1 요청과 응답 이해하기</h3> <ul><li>요청과 응답은 이벤트 방식으로 생각. 클라이언트로부터 요청이 왔을 떄 어떤 작업을 수행할지 이벤트 리스너를 미리 등록.</li></ul> <h4 id="note-localhost와-포트란"><a href="#note-localhost와-포트란" class="header-anchor">#</a> Note. localhost와 포트란?</h4> <ul><li>localhost는 현재 컴퓨터의 내부 주소를 가리킵니다.</li> <li>서버는 프로세스에 포트를 다르게 할당하여 들어오는 요청을 구분합니다.</li></ul> <h3 id="_4-2-쿠키와-세션-이해하기"><a href="#_4-2-쿠키와-세션-이해하기" class="header-anchor">#</a> 4.2 쿠키와 세션 이해하기</h3> <ul><li>서버는 요청에 대한 응답을 할 때 쿠키를 같이 보내줌.</li> <li>쿠키는 단순한 '키-값'의 쌍.</li> <li>서버로부터 쿠키가 오면 웹 브라우저는 쿠키를 저장해두었다가 요청시마다 쿠키를 같이 보냄</li> <li>서버는 요청에 들어 있는 쿠키를 읽어서 사용자가 누구인지 파악.</li> <li>브라우저는 쿠키가 있다면 자동으로 보내주므로 따로 처리할 필요가 없음.</li> <li>서버에서 브라우저로 쿠키를 보낼 때만 코드를 작성하여 처리.</li> <li>쿠키는 요청과 응답의 헤더에 저장.</li> <li>요청과 응답은 각각 헤더와 body를 가짐.</li></ul> <h4 id="note-http-상태-코드"><a href="#note-http-상태-코드" class="header-anchor">#</a> Note. HTTP 상태 코드</h4> <ul><li>2XX: 성공을 알리는 상태 코드. 대표적으로 200(성공), 201(작성됨)이 많이 사용됨</li> <li>3XX: 리다이렉션(다른 페이지로 이동)을 알리는 상태 코드. 301(영구이동), 302(임시이동)</li> <li>4XX: 요청 오류를 나타냄. 401(권한없음), 403(금지됨), 404(찾을 수 없음)</li> <li>5XX: 서버 오류를 나타냄. 요청은 제대로 왔지만 서버에 오류가 생겼을 때 발생. 이 오류가 뜨지 않게 주의해서 개발 필요. 이 오류를 클라이언트로 직접 보내는 경우는 없고, 예기치 못한 에러 발생 시 서버가 알아서 5XX대 코드를 보냅니다. 500(내부 서버 오류), 502(불량 게이트웨이), 503(서비스 사용 불가)</li></ul> <h4 id="note-헤더와-본문"><a href="#note-헤더와-본문" class="header-anchor">#</a> Note. 헤더와 본문</h4> <ul><li>요청과 응답은 모두 헤더와 본문을 가짐.</li> <li>헤더는 요청 또는 응답에 대한 정보를 가지는 곳.</li> <li>본문은 서버와 클라이언트 간에 주고받을 실제 데이터를 담아두는 공간.</li> <li>쿠키는 부가적인 정보이므로 헤더에 저장합니다.</li> <li>General은 공통된 해더, Request Headers는 요청의 헤더, Response Headers는 응답의 헤더</li></ul> <h3 id="_4-3-rest-api와-라우팅"><a href="#_4-3-rest-api와-라우팅" class="header-anchor">#</a> 4.3 REST API와 라우팅</h3> <ul><li>REpresentational State Transfer의 약어</li> <li>서버의 자원을 정의하고, 자원에 대한 주소를 지정하는 방법</li> <li>주소는 의미를 명확히 전달하기 위해 명사로 구성.</li> <li>HTTP 요청 메서드
<ul><li>GET: 서버자원을 가져올때</li> <li>POST: 서버에 자원을 새로 등록</li> <li>PUT: 서버의 자원을 요청에 들어 있는 자원으로 치환</li> <li>PATCH: 서버 자원의 일부만 수정하고자 할 때</li> <li>DELETE: 서버의 자원을 삭제하고자 할 때</li></ul></li> <li>GET 메서드 같은 경우에는 브라우저에서 캐싱할 수 있음</li> <li>HTTP 프로토콜을 사용하면 클라이언트에 상관없이 서버와 소통 가능
<ul><li>ex) ios, 안드로이드, 웹, ...</li></ul></li></ul> <h3 id="_4-4-https와-http2"><a href="#_4-4-https와-http2" class="header-anchor">#</a> 4.4 https와 http2</h3> <ul><li>https 모듈은 웹 서버에 SSL 암호화를 추가.</li> <li>노드의 http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용가능케 해줌.</li> <li>http/2는 요청 및 응답 방식이 개선되어 효율적이고 웹의 속도도 개선.</li></ul> <h3 id="_4-5-cluster"><a href="#_4-5-cluster" class="header-anchor">#</a> 4.5 cluster</h3> <ul><li>cluster 모듈은 싱글 스레드인 노드가 CPU 코어를 모두 사용케 해주는 모듈.</li> <li>포트를 공유하는 노드 프로세스를 여러 개 둘 수도 있어 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산.</li> <li>예를 들어 코어가 8개인 서버에서 노드는 보통 코어를 하나만 활용하는데 위 모듈을 설정하여 코어 하나당 노드 프로세스 하나가 돌아가게 설정 가능.</li> <li>세션을 공유하지 못하는 단점이 있음. 이는 Redis 등의 서버를 도입하여 해결할 수 있음.</li> <li>예기치 못한 에러로 인해 서버가 종료되는 현상을 방지할 수 있어 클러스터링을 적용해두는 것이 좋음.
<ul><li>더 중요한건 오류 자체의 원인을 찾아 해결하는것.</li></ul></li> <li>실무에서는 pm2 등의 모듈로 cluster 기능을 사용</li></ul> <h2 id="_5장-패키지-매니저"><a href="#_5장-패키지-매니저" class="header-anchor">#</a> 5장 패키지 매니저</h2> <h3 id="_5-1-npm-알아보기"><a href="#_5-1-npm-알아보기" class="header-anchor">#</a> 5.1 npm 알아보기</h3> <ul><li>Node Package Manager</li></ul> <h4 id="note-yarn"><a href="#note-yarn" class="header-anchor">#</a> Note. yarn</h4> <ul><li>페이스북이 내놓은 패키지 매니저.</li> <li>npm 서버가 너무 느릴 경우 yarn으로 패키지를 설치</li></ul> <h3 id="_5-2-package-json으로-패키지-관리하기"><a href="#_5-2-package-json으로-패키지-관리하기" class="header-anchor">#</a> 5.2 package.json으로 패키지 관리하기</h3> <ul><li>설치한 패키지를 관리하는 파일이 package.json</li></ul> <h4 id="note-라이선스"><a href="#note-라이선스" class="header-anchor">#</a> Note. 라이선스</h4> <ul><li>오픈소스라고 해도 설치 전에 라이선스를 확인 필요.</li> <li>ISC, MIT, BSD 라이선스는 사용한 패키지와 라이선스만 밝혀주면 자유롭게 사용</li> <li>Apache 라이선스는 사용은 자유롭지만 특허권에 대한 제한이 포함.</li> <li>GPL 계열의 패키지를 사용한 패키지를 배포할 때는 자신의 패키지도 GLP로 배포하고 소스 코드도 공개해야 함.</li> <li>상용 프로그램을 개발했을 때 법적 문제가 생길 수 있음.</li></ul> <h4 id="note-npm-warn-npmtest-0-0-1-no-repository-field"><a href="#note-npm-warn-npmtest-0-0-1-no-repository-field" class="header-anchor">#</a> Note. npm WARN npmtest@0.0.1 No repository field</h4> <ul><li>이 경고는 package.json에 repository 속성이 없어서 발생.</li> <li>저장소에 저장한 후 속성을 만들고 주소를 적으면 됨.</li></ul> <h4 id="note-save-옵션"><a href="#note-save-옵션" class="header-anchor">#</a> Note. --save 옵션</h4> <ul><li>npm@5부터는 기본값으로 설정되어 있으므로 따로 붙이지 않아도 됨</li></ul> <h4 id="note-npx-명령어"><a href="#note-npx-명령어" class="header-anchor">#</a> Note. npx 명령어</h4> <ul><li>전역설치 하기 싫은 경우 npx를 사용해서 전역 설치한 것과 같은 효과를 얻을 수 있음.</li></ul> <h4 id="note-npm에-등록되지-않은-패키지"><a href="#note-npm에-등록되지-않은-패키지" class="header-anchor">#</a> Note. npm에 등록되지 않은 패키지</h4> <ul><li>모든 패키지가 npm에 등록되어 있는 것은 아니다.</li> <li>GitHub나 nexus 등의 저장소에 보관되어 있을 경우 npm install [저장소 주소] 명령어를 통해 설치</li></ul> <h4 id="note-명령어-줄여쓰기"><a href="#note-명령어-줄여쓰기" class="header-anchor">#</a> Note. 명령어 줄여쓰기</h4> <ul><li>npm i (install)</li> <li>-D (--save-dev)</li> <li>-g (-global)</li></ul> <h3 id="_5-3-패키지-버전-이해하기"><a href="#_5-3-패키지-버전-이해하기" class="header-anchor">#</a> 5.3 패키지 버전 이해하기</h3> <ul><li>노드 패키지들의 버전은 항상 세 자리</li> <li>SemVer 방식의 버전 넘버링. Semantic Versioning(유의적 버전)의 약어.</li> <li>첫 번째 자리는 major 버전. 0이면 초기 개발 중. 1부터는 정식 버전이라는 뜻.</li> <li>major 버전은 하위 호환이 안 될 정도로 패키지의 내용이 수정 되었을 때 올린다.</li> <li>두 번째 자리는 minor 버전. minor 버전은 하위 호환이 되는 기능 업데이트 시에 올림.</li> <li>세 번째 자리는 patch 버전. 기존 기능에 문제가 있어 수정한 것을 내놓았을 때 올림.</li> <li>^기호는 minor 버전까지만 설치 또는 업데이트</li> <li>~기호는 patch 버전까지만 설치 또는 업데이트</li></ul> <h3 id="_5-4-기타-npm-명령어"><a href="#_5-4-기타-npm-명령어" class="header-anchor">#</a> 5.4 기타 npm 명령어</h3> <ul><li>새로운 기능이 추가되거나 버그를 고친 버전이 나올때 업데이트 할 수 있는 패키지 가 있는지 확인해보는 명령어
<ul><li>npm outdated</li></ul></li> <li>Current와 Wandted 가 다르면 업데이트가 필요한 경우.
<ul><li>npm update [패키지명] 으로 업데이트</li></ul></li> <li>npm uninstall [패키지명]
<ul><li>npm rm [패키지명] : 같은 삭제 명령</li></ul></li> <li>npm search [검색어] : 패키지 검색
<ul><li>gui 환경에서는 npmjs.com 에서 브라우저로 검색하는 것이 편함.</li></ul></li> <li>npm info [패키지명] : 패키지 세부 정보 파악.</li> <li>npm adduser : npm 로그인을 위한 명령어. 패키지를 배포할 때 로그인이 필요. 배포 안할거면 가입 필요없음.</li> <li>npm whoami : 로그인한 사용자 정보.</li> <li>npm logout : npm adduser로 로그인한 계정을 로그아웃.</li> <li>npm version [버전] : package.json의 버전을 올려줌.
<ul><li>major, minor, patch라는 문자열을 넣어서 해당 부분의 숫자를 1 올릴 수도 있음.</li></ul></li> <li>npm deprecate [패키지명][버전][메시지] : 해당 패키지를 설치할 때 경고 메시지를 띄우게 하는 명령어. 자신의 패키지에만 적용 가능. 다른 사용자들이 버그가 있는 버전의 패키지를 설치할 떄 경고 메시지가 출력.</li> <li>npm publish : 자신이 만든 패키지를 배포할 때 사용.</li> <li>npm unpublish : 배포한 패키지를 제거할 때 사용. 24시간 이내에 배포한 패키지만 제거 가능.</li> <li>그 외 <a href="https://docs.npmjs.com/" target="_blank" rel="noopener noreferrer">공식문서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>의 CLI Commands 에서 확인.</li></ul> <h3 id="_5-5-패키지-배포하기"><a href="#_5-5-패키지-배포하기" class="header-anchor">#</a> 5.5 패키지 배포하기</h3> <ul><li>누군가가 이름을 사용하는지 확인하려면 npm info [패키지명]을 콘솔에 입력.</li> <li>굳이 남이 사용하는 패키지 이름으로 배포하고 싶다면 네임스페이스를 쓰는 방법도 있음.</li></ul> <h4 id="note-원하는-이름이-이미-사용-중이라면"><a href="#note-원하는-이름이-이미-사용-중이라면" class="header-anchor">#</a> Note. 원하는 이름이 이미 사용 중이라면?</h4> <ul><li>그 패키지가 아무 의미 없이 이름만 차지하고 있다면
<ul><li>npm owner ls [패키지명] 으로 해당 패키지의 제작자의 이메일을 확인하고 패키지를 유지 중인지 메일을 보내본다.</li> <li>참조로 support@npmjs.com을 지정하면 npm 지원팀에게도 메일이 보내집니다.</li> <li>몇 주간 당사자 간에 이름 분쟁이 해결되지 않는다면 npm 팀에서 해결해줍니다.</li></ul></li></ul> <h4 id="warning-npm-배포-시-주의사항"><a href="#warning-npm-배포-시-주의사항" class="header-anchor">#</a> Warning. npm 배포 시 주의사항</h4> <ul><li>배포 전에 개인 정보가 코드에 있는지 확인.</li> <li>서비스의 비밀키 같은 경우 타인이 그 키를 사용해서 과금을 유발할 수 있음.</li> <li>실제로 사용할 패키지가 아님에도 이름 선점하는 행위는 삼가</li> <li>기존에 있는 패키지와 비슷한 이름으로 새 패키지를 배포하거나 다른 패키지의 코드를 살짝 수정해서 새로 배포하는 경우에는 꼭 원작자의 허락을 받기 바람.</li></ul> <h3 id="_5-6-함께-보면-좋은-자료"><a href="#_5-6-함께-보면-좋은-자료" class="header-anchor">#</a> 5.6 함께 보면 좋은 자료</h3> <ul><li><a href="https://docs.npm.com/cli" target="_blank" rel="noopener noreferrer">npm 명령어 설명서<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://npmcompare.com" target="_blank" rel="noopener noreferrer">패키지 간 비교<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://npmtrends.com" target="_blank" rel="noopener noreferrer">패키지 다운로드 추이<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://docs.npm.com/misc/scope" target="_blank" rel="noopener noreferrer">패키지명에 네임스페이스 설정하기<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="_6장-익스프레스-웹-서버-만들기"><a href="#_6장-익스프레스-웹-서버-만들기" class="header-anchor">#</a> 6장. 익스프레스 웹 서버 만들기</h2> <ul><li>익스프레스는 http 모듈의 요청과 응답 객체에 추가 기능들을 부여.</li> <li>기존 메서드들도 계속 사용할 수 있고, 편리한 메서드들을 추가하여 기능을 보완.</li> <li>코드를 분리하기 쉽게 만들어 관리도 용이.</li></ul> <h3 id="_6-1-express-generator로-빠르게-설치하기"><a href="#_6-1-express-generator로-빠르게-설치하기" class="header-anchor">#</a> 6.1 Express-generator로 빠르게 설치하기</h3> <ul><li>Express-generator 패키지 전역 설치
<ul><li>프레임워크에 필요한 package.json을 만들어주고 기본 폴더 구조까지 잡아주는 패키지</li></ul></li></ul> <h4 id="note-view-pug-란"><a href="#note-view-pug-란" class="header-anchor">#</a> Note. --view=pug 란?</h4> <ul><li>Express-generator는 기본적으로 Jade를 템플릿 엔진으로 설치.</li> <li>Jade는 Pug로 개명한 지 오래 됨.</li> <li>옛 버전인 Jade 대신 최신 버전인 Pug를 설치하기 위한 옵션.</li> <li>Pug 대신 EJS를 템플릿 엔진으로 사용하고 싶다면 --view=ejs를 입력</li></ul> <h3 id="_6-2-익스프레스-구조-이해하기"><a href="#_6-2-익스프레스-구조-이해하기" class="header-anchor">#</a> 6.2 익스프레스 구조 이해하기</h3> <h3 id="_6-3-미들웨어"><a href="#_6-3-미들웨어" class="header-anchor">#</a> 6.3 미들웨어</h3> <ul><li>요청과 응답의 중간(middle, 미들)에 위치하여 미들웨어라고 부릅니다.</li> <li>라우터와 에러 핸들러 또한 미들웨어의 일종이므로 미들웨어가 익스프레스의 전부라고 해도 과언이 아님.</li> <li>미들웨어는 요청과 응답을 조작하여 기능을 추가하기도 하고, 나쁜 요청을 걸러내기도 합니다.</li> <li>미들웨어는 주로 app.use와 함께 사용됩니다.</li></ul> <h4 id="_6-3-1-커스텀-미들웨어-만들기"><a href="#_6-3-1-커스텀-미들웨어-만들기" class="header-anchor">#</a> 6.3.1 커스텀 미들웨어 만들기</h4> <ul><li>미들웨어 안에서 next()를 호출해야 다음 미들웨어로 넘어감.</li> <li>next 함수는 인자의 종류로 기능이 구분됩니다. 인자를 넣지 않으면 단순하게 다음 미들웨어로 넘어감.</li> <li>next 함수의 인자로 route를 넣으면 특수한 기능을 함. 라우터를 배울 때 함께 알아본다.</li> <li>route 외의 다른 값을 넣으면 다른 미들웨어나 라우터를 건너 뛰고 바로 에러 핸들러로 이동. 넣어준 값은 에러에 대한 내용으로 간주.</li> <li>에러 핸들링 미들웨어는 일반적으로 미들웨어 중 제일 아래에 위치하여 위에 있는 미들웨어에서 발생하는 에러를 받아서 처리.</li></ul> <h5 id="note-코드-스타일"><a href="#note-코드-스타일" class="header-anchor">#</a> Note. 코드 스타일</h5> <ul><li>현재 Express-generator는 ES5 문법의 코드를 생성합니다.</li> <li>9장 부터는 Express-generator 없이 ES2015+ 문법을 사용하여 실습</li></ul> <h4 id="_6-3-2-morgan"><a href="#_6-3-2-morgan" class="header-anchor">#</a> 6.3.2 morgan</h4> <ul><li>요청에 대한 정보를 콘솔에 기록해줍니다.</li> <li>함수의 인자로 dev 대신 short, common, combined 등을 줄 수 있습니다.</li> <li>개발시에는 short, dev를 많이 쓰고, 배포시에는 common이나 combined를 많이 사용.</li> <li>파일이나 db에 로그를 남길 수도 있지만 이러한 작업에는 winston 모듈을 더 많이 사용합니다.</li></ul> <h4 id="_6-3-3-body-parser"><a href="#_6-3-3-body-parser" class="header-anchor">#</a> 6.3.3 body-parser</h4> <ul><li>요청의 본문을 해석해주는 미들웨어 입니다. 보통 폼 데이터나 ajax 요청의 데이터를 처리합니다. 다음과 같이 사용합니다.</li> <li>익스프레스 4.16.0 버전부터 body-parser의 일부기능이 익스프레스에 내장되어서 설치하지 않고 처리 가능.</li> <li>body-parser는 JSON과 URL-encoded 형식의 본문 외에도 Raw, Text 형식의 본문을 추가로 해석 가능.</li> <li>Raw는 본문이 버퍼 데이터일 때, Text는 본문이 텍스트 데이터일 때 해석하는 미들웨어. 서비스에 적용하고 싶다면 body-parser를 설치해서 적용.</li> <li>보통 폼 전송은 URL-encoded 방식을 주로 사용.</li> <li>urlencoded 메서드를 보면 { extended: false }라는 옵션이 들어 있는데 false면 노드의 querystring 모듈을 사용하여 쿼리스트링을 해석하고, true 면 qs 모듈을 사용하여 쿼리스트링을 해석.</li> <li>qa 모듈은 내장 모듈이 아니라 npm 패키지이며, querystring 모듈의 기능을 조금 더 확장한 모듈.</li> <li>POST와 PUT 요청의 본문을 전달받을때 req.on('data')와 req.on('end')로 스트림을 사용하던 것이 body-parser를 사용하면 필요가 없다. 패키지가 내부적으로 본문을 해석해 req.body에 추가해줌.</li> <li>body-parser가 모든 본문을 해석해주는 것은 아님. multipart/form-data 같은 폼을 통해 전송된 데이터는 해석하지 못한다. 이는 다른 모듈을 사용해서 해석해야 함.</li></ul> <h4 id="_6-3-4-cookie-parser"><a href="#_6-3-4-cookie-parser" class="header-anchor">#</a> 6.3.4 cookie-parser</h4> <ul><li>요청에 동봉된 쿠키를 해석</li> <li>4.2절의 parseCookies 함수와 기능이 비슷.</li> <li>해석된 쿠키들은 req.cookies 객체에 들어갑니다.</li> <li>첫 번째 인자로 문자열을 넣어주면 쿠키들은 제공된 문자열로 서명된 쿠기가 됩니다.</li> <li>서명된 쿠키는 클라이언트에서 수정했을 때 에러가 발생하므로 클라이언트에서 쿠키로 위험한 행동을 하는 것을 방지 가능.</li></ul> <h4 id="_6-3-5-static"><a href="#_6-3-5-static" class="header-anchor">#</a> 6.3.5 static</h4> <ul><li>static 미들웨어는 정적인 파일들을 제공. 익스프레스 4 버전에서 유일하게 내장되어 있던 미들 웨어</li> <li>익스프레스 4.16.0 버전에서는 body-parser의 일부분이 내장되어 이제는 유일한 내장 미들웨어가 아님.</li> <li>익스프레스를 설치하면 따라오므로 따로 설치할 필요가 없음.</li> <li>함수의 인자로 정적 파일들이 담겨있는 폴더를 지정.</li> <li>서버의 폴더 경로와 요청 경로를 다르게 해서 외부인이 서버의 구조를 쉽게 파악할 수 없다. (보안)</li> <li>정적 파일을 제공할 주소를 지정할 수도 있다.</li> <li>요청에 부합하는 정적 파일을 발견한 경우 응답으로 해당 파일을 전송</li> <li>응답을 보낼 경우 다음에 나오는 라우터는 실행되지 않음. 파일을 찾지 못했다면 요청을 라우터로 넘김.</li> <li>자체적으로 정적 파일 라우터 기능을 수행하므로 최대한 위쪽에 배치하는 것이 좋다. 서버가 쓸데없는 미들웨어 작업을 하는 것을 방지.</li> <li>필자는 보통 morgan 다음에 배치. morgan보다도 더 위로 올리면 정적 파일 요청이 기록되지 않음.</li> <li>요청을 기록하는 morgan을 제외하고 정적 파일을 제공하는데 영향을 끼치지 않는 json, urlencoded, cookie-parser를 거치는 것은 낭비.</li> <li>서비스에 따라 쿠키 같은 것이 정적 파일을 제공하는 데 영향을 끼칠 수도 있음.</li> <li>자신의 서비스에 맞는 위치를 선택.</li></ul> <h4 id="_6-3-6-express-session"><a href="#_6-3-6-express-session" class="header-anchor">#</a> 6.3.6 express-session</h4> <ul><li>세션 관리용 미들웨어. 로그인 등의 이유로 세션을 구현할 때 유용.</li> <li>express-generator로는 설치 되지 않음.</li> <li>express-session 1.5 버전 이전에는 내부적으로 cookie-parser를 사용하고 있어서 cookie-parser 미들웨어보다 뒤에 위치해야 했지만, 1.5 버전 이후부터는 사용하지 않게 되어 순서가 상관 없어 졌습니다. 그래도 현재 어떤 버전을 사용하고 있는지 모른다면 뒤에 놓는 것이 안전합니다.</li> <li>express-session은 인자로 세션에 대한 설정을 받습니다.</li> <li>resave는 요청이 왔을 때 세션에 수정 사항이 생기지 않더라도 세션을 다시 저장할지에 대한 설정. saveUninitialized는 세션에 저장할 내역이 없더라도 세션을 저장할지에 대한 설정. 보통 방문자를 추적할 때 사용됩니다. 현재는 둘다 필요없으므로 false</li> <li>secret은 필수 항목으로 비밀키와 같은 역할</li> <li>express-session은 세션 관리 시 클라이언트에 쿠키를 보내는데 이를 세션 쿠키라고 부른다. 안전하게 전송하려면 쿠키에 서명을 추가해야하고 이때 secret의 값이 필요. cookie-parser의 secret과 같게 설정해야 함.</li> <li>cookie 옵션은 세션 쿠키에 대한 설정. 일반적인 쿠키 옵션은 모두 제공. httpOnly를 사용해서 클라에서 쿠키를 확인하지 못하도록 했고, secure는 false로 해서 https가 아닌 환경에서도 사용할 수 있게 했음. 배포 시에는 https를 적용하고 secure도 true로 설정하는 것이 좋음.</li> <li>store라는 옵션도 있는데 배포시에는 데이터베이스를 연결하여 세션을 유지하는 것이 좋습니다. 보통 redis가 자주 쓰입니다. 레디스의 사용 방법에 대해서는 15.1.8 절에서 설명.</li> <li>express-session은 req 객체 안에 req.session 객체를 만듭니다.</li> <li>이 객체에 값을 대입하거나 삭제해서 세션을 변경할 수 있습니다.</li> <li>세션을 한변에 삭제하려면 req.session.destroy() 메서드 호출</li> <li>현재 세션의 아이디는 req.sessionID로 확인</li></ul> <h4 id="_6-3-7-connect-flash"><a href="#_6-3-7-connect-flash" class="header-anchor">#</a> 6.3.7 connect-flash</h4> <ul><li>상대적으로 중요도가 떨어지는 미들웨어. 일회성 메시지들을 웹 브라우저에 나타낼 때 좋습니다. express-session과 마찬가지로 직접 설치해주어야 합니다.</li> <li>connect-flash 미들웨어는 cookie-parser와 express-session을 사용하므로 이들보다는 뒤에 위치해야 합니다.</li> <li>flash 미들웨어는 req 객체에 req.flash 메서드를 추가합니다. req.flash(키, 값)으로 해당키에 값을 설정하고, req.flash(키)로 해당 키에 대한 값을 불러옵니다.</li> <li>일회성 메시지라는 성질을 이용하여 로그인 에러나 회원가입 에러 같은 일회성 경고 메시지는 flash 미들웨어로 보내면 좋습니다.</li></ul> <h3 id="_6-4-router-객체로-라우팅-분리하기"><a href="#_6-4-router-객체로-라우팅-분리하기" class="header-anchor">#</a> 6.4 Router 객체로 라우팅 분리하기</h3> <ul><li>익스프레스를 사용하는 이유 중 하나가 바로 라우팅을 깔끔하게 관리할 수 있다는 점</li> <li>라우팅 미들웨어는 첫 번째 인자로 주소를 받아서 특정 주소에 해당하는 요청이 왔을 때만 미들웨어가 동작하게 할 수 있음.</li> <li>use 대신 get, post, put, patch, delete 같은 HTTP 메서드를 사용할 수도 있습니다.</li> <li>use 메서드는 모든 HTTP 메서드에 대해 요청 주소만 일치하면 됨.</li> <li>router 객체는 express.Router()로 만들었습니다.</li> <li>router에도 app처럼 use, get, post, put, patch, delete 같은 메서드를 붙일 수 있습니다. use를 제외하고는 각각 HTTP 요청 메서드와 상응.</li> <li>app.use 처럼 router 하나에 미들웨어를 여러개 장착할 수도 있습니다.</li> <li>실제 라우터 로직이 실행되는 미들웨어 전에 로그인 여부 또는 관리자 여부를 체크하는 미들웨어를 중간에 넣어두곤 합니다.</li> <li>res.render 메서드는 익스프레스가 응답 객체에 새로 추가한 메서드로 템플릿 엔진을 사용하는 부분입니다. 템플릿 엔진은 6.5절에서 다룹니다.</li> <li>라우터를 사용할 필요업이 app을 사용해도 기능은 동일한데 코드관리를 위해 라우터를 별도로 분리합니다.</li> <li>라우터에서는 요청에 대한 응답을 보내거나 에러 핸들러로 요청을 넘겨야 합니다.</li> <li>응답을 보내지 않으면 브라우저는 계속 응답을 기다립니다. 제한 시간이 있어 영원히 기다리지는 않지만, 기다리는 동안 다른 동작을 수행할 수 없을 수도 있습니다.</li> <li>res 객체에 들어 있는 메서드들로 응답을 보냅니다.</li> <li>next 함수에는 라우터에서만 동작하는 특수 기능이 있습니다. next('route')입니다. 라우터에 연결된 나머지 미들웨어들을 건너뛰고 싶을 때 사용합니다.</li> <li>라우터 주소에는 특수한 패턴을 사용할 수 있음. 아래는 자주 쓰이는 패턴</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/users/:id'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>params<span class="token punctuation">,</span> req<span class="token punctuation">.</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>:id 이면 req.params.id로 조회 가능</li> <li>주소에 쿼리스트링을 쓸 때도 있습니다. 쿼리스트링 키-값 정보는 req.query 객체 안에 들어 있습니다.</li> <li>예를 들어 /users/123?limit=5&amp;skip=10 이라는 주소의 요청이 들어왔을 때 req.params와 req.query 객체는 다음과 같음</li> <li>{id: '123'} {limit:'5', skip:'10'}</li> <li>이 패턴을 사용할 때 주의할 점은 일반 라우터보다 뒤에 위치해야 함. 다양한 라우터를 아우르는 와일드카드 역할을 하므로 일반 라우터보다는 뒤에 위치해야 다른 라우터를 방해하지 않습니다.</li> <li>에러가 발생하지 않았다면 라우터는 요청을 보낸 클라이언트에 응답을 보내주어야 합니다. 응답 메서드는 여러 가지지만 이 책에서는 send, sendFile, json, redirect, render를 주로 사용</li> <li>send는 만능 메서드. 버퍼 데이터나 문자열을 전송하거나, HTML 코드를 전송하기도 하고, JSON 데이터도 전송할 수 있습니다.</li> <li>sendFile은 파일을 응답으로 보내주는 메서드. json은 JSON 데이터를 보내줌.</li> <li>redirect는 응답을 다른 라우터로 보낸다. 예를 들어 로그인 완료 후 다시 메인 화면으로 돌아갈 때 사용.</li> <li>기본적으로는 200 HTTP 상태 코드를 응답하지만(res.redirect는 302), 직접 바꿔줄 수도 있습니다. 다음과 같이 status 메서드를 먼저 사용하면 됩니다.</li> <li>render 메서드는 템플릿 엔진을 렌더링할 때 사용. views 폴더 안 pug 확장자를 가지고 있는 파일들이 템플릿 엔진</li> <li>요청을 처리할 수 있는 라우터가 없다면 다음 미들웨어로 넘어갑니다. 404 HTTP 상태 코드를 보내주어야 하므로 다음 미들웨어에서 새로운 에러를 만들고 에러의 상태코드를 404로 설정한 뒤 에러 처리 미들웨어로 넘깁니다.</li></ul> <h4 id="warning-응답을-여러-번-보내는-경우"><a href="#warning-응답을-여러-번-보내는-경우" class="header-anchor">#</a> Warning. 응답을 여러 번 보내는 경우</h4> <ul><li>하나의 요청에 대한 응답은 한 번만 보내야 됨. 두 번 이상 보내면 에러 발생.</li> <li>Error: Cant't set headers after they are sent.</li> <li>위와 같은 에러 발생시 라우터에서 res 객체의 응답 메서드가 두 번 이상 사용되지 않았는지 점검해보아야 함.</li></ul> <h3 id="_6-5-템플릿-엔진-사용하기"><a href="#_6-5-템플릿-엔진-사용하기" class="header-anchor">#</a> 6.5 템플릿 엔진 사용하기</h3> <ul><li>템플릿 엔진은 자바스크립트를 사용해서 HTML을 렌더링할 수 있게 해줌.</li> <li>기존 HTML과는 문법이 살짝 다를 수도 있고, 자바스크립트 문법이 들어 있기도 함.</li></ul> <h4 id="_6-5-1-pug-jade"><a href="#_6-5-1-pug-jade" class="header-anchor">#</a> 6.5.1 Pug(Jade)</h4> <ul><li>문법이 간단하여 코드의 양이 줄어듬.</li> <li>Ruby와 문법이 비슷. HTML과는 문법이 많이 다름.</li></ul> <h5 id="_6-5-1-1-html-표현"><a href="#_6-5-1-1-html-표현" class="header-anchor">#</a> 6.5.1.1 HTML 표현</h5> <ul><li>HTML과 다르게 화살관호(&lt;&gt;)와 닫는 태그가 없음</li> <li>탭 또는 스페이스로만 태그의 부모 자식 관계를 규명</li> <li>모든 파일에 동일한 종류의 들여쓰기를 적용. 들여쓰기에 오류가 있으면 제대로 렌더링 되지 않음.</li></ul> <h5 id="_6-5-1-2-변수"><a href="#_6-5-1-2-변수" class="header-anchor">#</a> 6.5.1.2 변수</h5> <ul><li>HTML과 다르게 자바스크립트 변수를 템플릿에 렌더링 할 수 있음.</li> <li>res.render 호출 시 보내는 변수를 Pug가 처리.</li> <li>res.render 메서드에 두 번째 인자로 변수 객체를 넣는 대신, app.js의 에러 처리 미들웨어처럼 res.locals 객체를 사용해서 변수를 넣을 수 있음. 템플릿 엔진이 res.locals 객체를 읽어서 변수를 집어 넣음. 이 방식의 장점은 현재 라우터뿐만 아니라 다른 미들웨어에서도 res.locals 객체에 접근할 수 있음.</li></ul> <h5 id="note-html-엔티티와-이스케이프"><a href="#note-html-엔티티와-이스케이프" class="header-anchor">#</a> Note. HTML 엔티티와 이스케이프</h5> <ul><li>자바스크립트 문자열과 HTML 텍스트를 혼용시 특수문자 때문에 가끔 에러가 발생.</li> <li><strong>강조</strong> 같은 자바스크립트 문자열이 있다면 이것을 HTML에 사용했을 때 태그로 오해할 소지가 있음.</li> <li>방지하기 위해서 특수 문자를 HTML 엔티티라는 코드로 변환.</li> <li>&lt; : &lt;</li> <li><blockquote><p>: &gt;</p></blockquote></li> <li>&amp; : &amp;</li> <li>띄어쓰기 :  </li> <li>&quot; : &quot;</li> <li>' : '</li></ul> <h5 id="_6-5-1-3-반복문"><a href="#_6-5-1-3-반복문" class="header-anchor">#</a> 6.5.1.3 반복문</h5> <ul><li>HTML과 다르게 반복문 사용 가능. 반복 가능한 변수인 경우일 때만 해당.</li> <li>each로 반복문 사용. 사용 시 인덱스도 가져올 수 있음.</li></ul> <h5 id="_6-5-1-4-조건문"><a href="#_6-5-1-4-조건문" class="header-anchor">#</a> 6.5.1.4 조건문</h5> <ul><li>if, else if, else를 사용 가능.</li> <li>case문도 가능</li></ul> <h5 id="_6-5-1-5-include"><a href="#_6-5-1-5-include" class="header-anchor">#</a> 6.5.1.5 include</h5> <ul><li>다른 Pug나 HTML 파일을 넣을 수 있음.</li> <li>헤더나 푸터, 네비게이션처럼 웹 제작 시 공통되는 부분을 따로 관리.</li></ul> <h5 id="_6-5-1-6-extends와-block"><a href="#_6-5-1-6-extends와-block" class="header-anchor">#</a> 6.5.1.6 extends와 block</h5> <ul><li>레이아웃을 정할 수 있음. 공통되는 레이아웃 부분을 따로 관리할 수 있어 좋음.</li> <li>include와도 함께 사용.</li> <li>레이아웃이 될 파일에는 공통된 마크업을 넣되, 페이지마다 달라지는 부분을 block으로 비워둠. block이 되는 파일에서는 extends 키워드로 레이아웃 파일을 지정하고 block 부분을 넣어줍니다.</li></ul> <h4 id="_6-5-2-ejs"><a href="#_6-5-2-ejs" class="header-anchor">#</a> 6.5.2 EJS</h4> <ul><li>HTML 문법을 그대로 사용하되 추가로 자바스크립트 문법을 사용 가능.</li> <li>자바의 JSP와 문법이 유사.</li> <li>view engine을 pug 대신 ejs로 바꿔줍니다.</li> <li>ejs 패키지도 설치 필요 ($ npm i ejs)</li></ul> <h5 id="_6-5-2-1-변수"><a href="#_6-5-2-1-변수" class="header-anchor">#</a> 6.5.2.1 변수</h5> <ul><li>변수는 &lt;%= %&gt;로 감쌉니다.</li> <li>내부에 변수를 사용할 수도 있습니다. 자바스크립트 코드는 &lt;% %&gt; 안에 적어줍니다.</li> <li>HTML을 이스케이프하고 싶지 않다면 &lt;%- %&gt;로 감싸줍니다.</li></ul> <h5 id="_6-5-2-2-반복문"><a href="#_6-5-2-2-반복문" class="header-anchor">#</a> 6.5.2.2 반복문</h5> <ul><li>자바스크립트 코드를 &lt;% %&gt; 안에 씁니다.</li> <li>Pug 처럼 따로 문법이 있지 않고, for나 while 같은 반복문을 사용하면 됨</li></ul> <h5 id="_6-5-2-3-조건문"><a href="#_6-5-2-3-조건문" class="header-anchor">#</a> 6.5.2.3 조건문</h5> <ul><li>조건문도 &lt;% %&gt; 안에 씁니다.</li> <li>case문도 가능</li></ul> <h5 id="_6-5-2-4-include"><a href="#_6-5-2-4-include" class="header-anchor">#</a> 6.5.2.4 include</h5> <ul><li>HTML 파일을 포함하려면 &lt;%- include(파일 경로, 데이터) %&gt;을 하면 됩니다.</li> <li>EJS는 Pug의 layout과 block은 지원하지 않음. 따라서 include로 중복되는 부분을 집어넣는 방식을 사용.</li></ul> <h4 id="_6-5-3-에러-처리-미들웨어"><a href="#_6-5-3-에러-처리-미들웨어" class="header-anchor">#</a> 6.5.3 에러 처리 미들웨어</h4> <ul><li>에러 처리 미들웨어는 error라는 템플릿 파일을 렌더링.</li> <li>렌더링 시 res.locals.message와 res.locals.error에 넣어준 값을 함께 렌더링.</li> <li>res.render에 변수를 대입하는 것 외에도, 이렇게 res.locals 속성에 값을 대입하여 템플릿 엔진에 변수를 주입 가능.</li> <li>error 객체는 시스템 환경이 development가 아닌 경우에만 표시.</li> <li>배포 환경인 경우에는 에러 메시지가 표시되지 않음. 에러 메시지가 노출되면 보안에 취약 할 수 있기 때문.</li></ul> <h3 id="_6-6-함께-보면-좋은-자료"><a href="#_6-6-함께-보면-좋은-자료" class="header-anchor">#</a> 6.6 함께 보면 좋은 자료</h3> <h2 id="_7장-mysql"><a href="#_7장-mysql" class="header-anchor">#</a> 7장 MySQL</h2> <h3 id="_7-1-데이터베이스란"><a href="#_7-1-데이터베이스란" class="header-anchor">#</a> 7.1 데이터베이스란?</h3> <ul><li>데이터베이스는 관련성을 가지며 중복이 없는 데이터들의 집합.</li> <li>보통 서버의 하드 디스크나 SSD 등의 저장 매체에 데이터를 저장.</li></ul> <h3 id="_7-2-mysql-설치하기"><a href="#_7-2-mysql-설치하기" class="header-anchor">#</a> 7.2 MySQL 설치하기</h3> <h3 id="_7-3-워크벤치-설치하기"><a href="#_7-3-워크벤치-설치하기" class="header-anchor">#</a> 7.3 워크벤치 설치하기</h3> <h3 id="_7-4-데이터베이스-및-테이블-생성하기"><a href="#_7-4-데이터베이스-및-테이블-생성하기" class="header-anchor">#</a> 7.4 데이터베이스 및 테이블 생성하기</h3> <h4 id="_7-4-1-데이터베이스-생성하기"><a href="#_7-4-1-데이터베이스-생성하기" class="header-anchor">#</a> 7.4.1 데이터베이스 생성하기</h4> <ul><li>CREATE SCHEMA와 같이 MySQL이 기본적으로 알고 있는 구문을 예약어라고 부른다. 소문자로 써도 되지만, 대분자로 쓰는 것이 좋다. nodejs와 같은 사용자 정의 이름과 구분하기 위해서.</li></ul> <h4 id="_7-4-2-테이블-생성하기"><a href="#_7-4-2-테이블-생성하기" class="header-anchor">#</a> 7.4.2 테이블 생성하기</h4> <ul><li>CREATE TABLE [데이터베이스명.테이블명]</li> <li>자주 쓰이는 컬럼의 자료형
<ul><li>INT : 정수 (소수까지 저장하고 싶다면 FLOAT이나 DOUBLE)</li> <li>VARCHAR(자릿수) / CHAR(자릿수) : CHAR는 고정 길이, VARCHAR는 가변 길이. CHAR에 주어진 길이보다 짧은 문자열을 넣는다면 부족한 자릿수만큼 스페이스가 채워짐.</li> <li>TEXT : 긴 글을 저장할 때 사용. 몇백 자 이내의 문자열은 보통 VARCHAR로 처리하고, 그보다 길면 TEXT로 처리</li> <li>TINYINT : -127 ~ 128까지의 정수를 저장. 1 또는 0만 저장한다면 Boolean과 같은 역할을 할 수 있다.</li> <li>DATETIM : 날짜와 시간에 대한 정보. 날짜 정보만 담는 DATE와 시간 정보만 담는 TIME자료형도 있다.</li></ul></li> <li>옵션
<ul><li>UNSIGNED : 숫자 자료형에 적용되는 옵션. 음수는 무시되고 양수의 저장범위가 늘어남. FLOAT, DOUBLE에는 UN 적용이 불가능. 나이처럼 음수가 나올 수 없는 컬럼은 체크해두는 것이 좋습니다.</li> <li>ZEROFILL : 숫자의 자릿수가 고정되어 있을 때 사용. 비어있는 자리에 모두 0을 넣는다.
<ul><li>ex) INT(4) 인데 숫자 1을 넣어었다면 0001이 됨.</li></ul></li> <li>DEFAULT now() : 데이터베이스 저장 시 해당 컬럼에 값이 없을 때 기본값을 대신 넣어줌. now() 대신 CURRENT_TIMESTAMP를 적어도 같은 뜻.</li> <li>PRIMARY KEY : 기본 키란 로우를 대표하는 고유한 값을 의미.</li> <li>UNIQUE INDEX : 해당 값이 고유해야 하는지에 대한 옵션.</li></ul></li> <li>그 외 설정
<ul><li>COMMENT : 테이블에 대한 보충 설명. 필수는 아님.</li> <li>DEFAULT CHARSET : utf8로 설정하지 않으면 한글이 입력안됨.</li> <li>ENGINE : 대표적으로 MyISAM과 InnoDB가 제일 많이 사용.</li></ul></li></ul> <h5 id="note-컬럼과-로우"><a href="#note-컬럼과-로우" class="header-anchor">#</a> Note. 컬럼과 로우</h5> <ul><li>컬럼과 로우가 교차하는 칸 하나는 필드라고 부른다.</li> <li>컬럼은 세로 필드의 집합</li> <li>로우는 가로 필드의 집합</li> <li>테이블에 데이터를 넣을 때는 미리 컬럼을 정의해두고, 컬럼에 맞춰 데이터를 넣으면 된다.</li></ul> <h3 id="_7-5-crud-작업하기"><a href="#_7-5-crud-작업하기" class="header-anchor">#</a> 7.5 CRUD 작업하기</h3> <h4 id="_7-5-1-create-생성"><a href="#_7-5-1-create-생성" class="header-anchor">#</a> 7.5.1 Create(생성)</h4> <ul><li>INSERT INTO [테이블명] ([컬럼1], [컬럼2], ...) VALUES ([값1], [값2], ...)</li></ul> <h4 id="_7-5-2-read-조회"><a href="#_7-5-2-read-조회" class="header-anchor">#</a> 7.5.2 Read(조회)</h4> <ul><li>SELECT * FROM [테이블명]</li> <li>특정 컬럼만 조회 가능.</li> <li>WHERE 절을 사용하면 특정 조건을 가진 데이터만 조회 가능.
<ul><li>AND는 조건들을 모두 만족하는 데이터를 찾고 OR은 조건들 중 어느 하나라도 만족하는 데이터를 찾음.</li></ul></li> <li>ORDER BY [컬럼명] [ASC|DESC] : 키워드를 사용하여 정렬.</li> <li>LIMIT [숫자] : 키워드를 사용해서 조회할 로우 개수를 설정.</li> <li>OFFSET [건너뛸 숫자] : 로우 개수를 몇개를 건너뛸지 설정</li></ul> <h4 id="_7-5-3-update-수정"><a href="#_7-5-3-update-수정" class="header-anchor">#</a> 7.5.3 Update(수정)</h4> <ul><li>UPDATE [테이블명] SET [컬럼명=바꿀값] WHERE [조건]</li></ul> <h4 id="_7-5-4-delete-삭제"><a href="#_7-5-4-delete-삭제" class="header-anchor">#</a> 7.5.4 Delete(삭제)</h4> <ul><li>DELETE FROM [테이블명] WHERE [조건]</li></ul> <h3 id="_7-6-시퀼라이즈-사용하기"><a href="#_7-6-시퀼라이즈-사용하기" class="header-anchor">#</a> 7.6 시퀼라이즈 사용하기</h3> <ul><li>MySQL 작업을 쉽게 할 수 있도록 도와주는 라이브러리.</li> <li>ORM으로 분류됨. ORM은 자바스크립트 객체와 데이터베이스의 릴레이션을 매핑 해주는 도구.</li> <li>MariaDB, PostgreSQL, SQLite, MSSQL 등 다른 데이터베이스도 같이 쓸 수 있음. 문법이 어느 정도 호환됨.</li> <li>자바스크립트 구문을 알아서 SQL로 바꿔줌.</li></ul> <h3 id="_7-6-1-mysql-연결하기"><a href="#_7-6-1-mysql-연결하기" class="header-anchor">#</a> 7.6.1 MySQL 연결하기</h3> <ul><li>폴더 내의 index.js 파일은 require 시 이름을 생략할 수 있다.</li> <li>sync 메서드를 사용하면 서버 실행 시 MySQL과 연동.</li></ul> <h3 id="_7-6-2-모델-정의하기"><a href="#_7-6-2-모델-정의하기" class="header-anchor">#</a> 7.6.2 모델 정의하기</h3> <ul><li>MySQL의 테이블은 시퀼라이즈의 모델과 대응.</li> <li>시퀼라이즈는 모델과 MySQL의 테이블을 연결해 주는 역할을 합니다.</li> <li>시퀼라이즈는 기본적으로 모델 이름은 단수형으로, 테이블 이름은 복수형으로 사용.</li> <li>id 컬럼은 알아서 기본 키로 연결하므로 적어줄 필요 없음.</li> <li>sequelize.define 메서드로 테이블명과 각 컬럼의 스펙을 입력.</li> <li>MySQL 테이블과 컬럼 내용이 일치해야 정확하게 대응.</li> <li>시퀼라이즈의 자료형은 MySQL의 자료형과는 조금 다름.
<ul><li>VARCHAR는 STRING</li> <li>INT는 INTEGER</li> <li>TINYINT는 BOOLEAN</li> <li>DATETIME은 DATE</li></ul></li> <li>INTEGER.UNSIGNED : UNSIGNED 옵션이 적용된 INT</li> <li>INTEGER.UNSIGNED.ZEROFILL : ZEROFILL 옵션도 사용</li> <li>allowNull : NOT NULL 옵션과 동일.</li> <li>unique : UNIQUE 옵션</li> <li>defaultValue : 기본값</li> <li>sequelize.literal 메서드는 인자로 넣은 문자를 그대로 사용하는 역할.</li> <li>define 메서드의 세 번째 인자는 테이블 옵션.
<ul><li>timestamps 속성이 true 면 시퀄라이즈는 createAt과 updateAt 컬럼을 추가. 로우가 생성될 때와 수정될 때의 시간이 자동으로 입력.</li></ul></li></ul> <h4 id="note-기타-테이블-옵션"><a href="#note-기타-테이블-옵션" class="header-anchor">#</a> Note. 기타 테이블 옵션.</h4> <ul><li>paranoid : timestamps 가 true여야 설정 가능. true로 설정하면 deleteAt 이라는 컬럼이 추가. 로우를 삭제하는 명령을 내렸을 때 제거 대신 제거된 날짜를 입력. 로우를 조회할 때는 deleteAt 값이 null인 로우를 조회. 데이터 복구를 염두에 둘 경우.</li> <li>underscored : createAt, updateAt, deleteAt 컬럼과 자동으로 생성해주는 관계 컬럼들의 이름을 스네이크케이스 형식을 바꾸어줌</li> <li>tableName : 테이블 이름을 다른 것으로 설정하고 싶을 때 사용. 시퀼라이즈는 define 메서드의 첫 번째 인자를 북수형으로 만들어 테이블 이름으로 사용. 이러한 자동 변환을 막고 싶으면 옵션에 값을 주어 해당 값으로 테이블 이름을 만들 수 있음.</li></ul> <h3 id="_7-6-3-관계-정의하기"><a href="#_7-6-3-관계-정의하기" class="header-anchor">#</a> 7.6.3 관계 정의하기</h3> <h4 id="_7-6-3-1-1-n"><a href="#_7-6-3-1-1-n" class="header-anchor">#</a> 7.6.3.1 1:N</h4> <ul><li>시퀼라이즈는 1:N 관계를 hasMany 라는 메서드로 표현.</li> <li>반대로 belongsTo 메서드도 있음.</li></ul> <h4 id="_7-6-3-2-1-1"><a href="#_7-6-3-2-1-1" class="header-anchor">#</a> 7.6.3.2 1:1</h4> <ul><li>1:1 관계에서는 hasOne 메서드를 사용.</li> <li>belongsTo와 hasOne이 반대여도 상관없다.</li></ul> <h4 id="_7-6-3-3-n-m"><a href="#_7-6-3-3-n-m" class="header-anchor">#</a> 7.6.3.3 N:M</h4> <ul><li>N:M 관계를 표현하기 위해 belongsToMany 메서드가 있습니다.</li> <li>N:M 관계 특성상 새로운 모델이 생성된다. through 속성에 그 이름을 적어주면 됨.</li></ul> <h4 id="_7-6-4-쿼리-알아보기"><a href="#_7-6-4-쿼리-알아보기" class="header-anchor">#</a> 7.6.4 쿼리 알아보기</h4> <ul><li>SQL문을 자바스크립트로 생성하는 시퀄라이즈 쿼리.</li> <li>로우를 생성할 때는 create 메서드
<ul><li>데이터를 입력 시 MySQL의 자료형이 아닌 시퀄리아즈 모델에 정의한 자료형 대로 입력.</li></ul></li> <li>여러 데이터를 조회 할 때는 findAll 메서드</li> <li>하나의 데이터만 조회시는 find 메서드</li> <li>attributes 옵션을 사용해서 원하는 컬럼만</li> <li>where 은 조건들을 나열하는 옵션.
<ul><li>자주 쓰이는 연산자 : Op.gt(초과), Op.gte(이상), Op.lt(미만), Op.lte(이하), Op.ne(같지 않음), Op.or(또는), Op.in(배열 요소 중 하나), Op.notIn(배열 요소와 모두 다름)</li> <li>Sequelize 객체 내부의 Op 객체를 불러와 사용.</li></ul></li> <li>Op.or 속성 : OR 연산</li> <li>정렬 : order 옵션</li> <li>조회할 로우 개수 설정 : limit 옵션</li> <li>수정은 update 메서드. 첫 번째 인자는 수정할 내용, 두 번째 인자는 수정 대상 로우 조건. where 옵션에 조건들 추가.</li> <li>삭제는 destroy 메서드. where 옵션에 조건 추가.</li></ul> <h4 id="_7-6-5-쿼리-수행하기"><a href="#_7-6-5-쿼리-수행하기" class="header-anchor">#</a> 7.6.5 쿼리 수행하기</h4> <h3 id="_7-7-함께-보면-좋은-자료"><a href="#_7-7-함께-보면-좋은-자료" class="header-anchor">#</a> 7.7 함께 보면 좋은 자료</h3> <h2 id="_8장-몽고디비"><a href="#_8장-몽고디비" class="header-anchor">#</a> 8장 몽고디비</h2> <h3 id="_8-1-nosql-vs-sql"><a href="#_8-1-nosql-vs-sql" class="header-anchor">#</a> 8.1 NoSQL vs SQL</h3> <ul><li>NoSQL(Not only SQL)</li> <li>SQL과 NoSQL비교
<ul><li>규칙에 맞는 데이터 입력 : 자유로운 데이터 입력</li> <li>테이블 간 JOIN 지원 : 컬렉션 간 JOIN 미지원</li> <li>트랜잭션 지원 : 트랜잭션 미지원</li> <li>안정성, 일관성 : 확장성, 가용성</li> <li>용어(테이블, 로우, 컬럼) : 용어(컬렉션, 다큐먼트, 필드)</li></ul></li> <li>컬렉션에 어떠한 데이터라도 들어갈수 있습니다.</li> <li>JOIN을 흉내낼 수는 있지만, 하나의 쿼리로 여러 테이블을 합치는 작업이 항상 가능하지는 않습니다.</li> <li>트랜잭션 기능이 아예 없다고는 말할 수 없지만, MySQL 같은 수준의 트랜잭션은 없습니다.</li> <li>데이터의 일관성을 보장해주는 기능이 약한 대신 데이터를 빠르게 넣을 수 있고, 쉽게 여러 서버에 데이터를 분산할 수 있습니다.</li> <li>SQL과 NoSQL은 각각 특징이 다르므로 알맞은 곳에 사용.</li> <li>빅데이터, 메시징, 세션 관리 등에는 확장성과 가용성을 위해 몽고디비를 사용할 수 있습니다.</li></ul> <h4 id="note-몽고디비의-트랜잭션"><a href="#note-몽고디비의-트랜잭션" class="header-anchor">#</a> Note. 몽고디비의 트랜잭션</h4> <ul><li>현재 몽고디비의 버전은 3입니다. 4 버전부터 트랜잭션을 지원한다고 발표했습니다.</li></ul> <h3 id="_8-2-몽고디비-설치하기"><a href="#_8-2-몽고디비-설치하기" class="header-anchor">#</a> 8.2 몽고디비 설치하기</h3> <h3 id="_8-3-컴퍼스-설치하기"><a href="#_8-3-컴퍼스-설치하기" class="header-anchor">#</a> 8.3 컴퍼스 설치하기</h3> <ul><li>몽고디비 GUI 관리 도구</li></ul> <h4 id="_8-3-4-커넥션-생성하기"><a href="#_8-3-4-커넥션-생성하기" class="header-anchor">#</a> 8.3.4 커넥션 생성하기</h4> <h3 id="_8-4-데이터베이스-및-컬렉션-생성하기"><a href="#_8-4-데이터베이스-및-컬렉션-생성하기" class="header-anchor">#</a> 8.4 데이터베이스 및 컬렉션 생성하기</h3> <ul><li>데이터베이스 생성 : use [데이터베이스명]</li> <li>데이터베이스 목록 확인 : show dbs</li> <li>현재 사용 중인 데이터베이스 확인 : db</li> <li>컬렉션 생성 : db.createCollection('컬렉션명')</li> <li>컬렉션 목록 확인 : show collections</li></ul> <h3 id="_8-5-crud-작업하기"><a href="#_8-5-crud-작업하기" class="header-anchor">#</a> 8.5 CRUD 작업하기</h3> <h4 id="_8-5-1-create-생성"><a href="#_8-5-1-create-생성" class="header-anchor">#</a> 8.5.1 Create(생성)</h4> <ul><li>몽고디비는 자바스크립트의 자료형을 따릅니다. 추가로 몇 가지 자료형이 있다.
<ul><li>Date, 정규표현식 같은 자바스크립트 객체를 자료형으로 사용 가능</li> <li>Binary Data, ObjectId, Int, Long, Decimal, Timestamp, Javascript 등의 추가 자료형</li> <li>Undefined와 Symbol은 몽고디비에서 자료형으로 사용하지 않음.</li></ul></li> <li>db.컬렉션명.save(다큐먼트) 로 다큐먼트 생성</li></ul> <h4 id="_8-5-2-read-조회"><a href="#_8-5-2-read-조회" class="header-anchor">#</a> 8.5.2 Read(조회)</h4> <ul><li>find({})는 컬렉션 내의 모든 다큐먼트 조회</li> <li>몽고디비는 자바스크립트 객체를 사용해서 명령어 쿼리를 생성하므로 특수 연산자가 사용
<ul><li>$gt(초과), $gte(이상), $lt(미만), $lte(이하), $ne(같지 않음), $or(또는), $in(배열 요소 중 하나) 등이 있다.</li></ul></li> <li>OR 연산은 $or를 사용.</li> <li>정렬은 sort 메서드 사용. -1은 내림차순, 1은 오름차순</li> <li>limit 메서드로 조회할 다큐먼트 개수 설정.</li> <li>다큐먼트 개수 설성지 skip 메서드로 몇 개를 건너뛸지 설정</li></ul> <h4 id="_8-5-3-update-수정"><a href="#_8-5-3-update-수정" class="header-anchor">#</a> 8.5.3 Update(수정)</h4> <ul><li>첫 번째 객체는 수정할 다큐먼트를 지정하는 객체</li> <li>두 번째 객체는 수정할 내용을 입력하는 객체.</li> <li>$set : 어떤 필드를 수정할지 정하는 연산자. 이 연산자를 사용하지 않고 일반 객체를 넣는다면 다큐먼트가 통 째로 두 번째 인자로 주어진 객체로 수정됨. 일부 필드만 수정 하고 싶을 때는 반드시 $set 연산자를 지정</li></ul> <h4 id="_8-5-4-delete-삭제"><a href="#_8-5-4-delete-삭제" class="header-anchor">#</a> 8.5.4 Delete(삭제)</h4> <ul><li>삭제할 다큐먼트에 대한 정보가 담긴 객체를 첫 번째 인자로 제공.</li></ul> <h3 id="_8-6-몽구스-사용하기"><a href="#_8-6-몽구스-사용하기" class="header-anchor">#</a> 8.6 몽구스 사용하기</h3> <ul><li>몽구스는 시퀼라이즈와 달리 ODM(Object Document Mapping) 이라고 불림.</li> <li>몽고디비에 없어서 불편한 기능들을 몽구스가 보완</li> <li>스키마라는 것이 추가.</li> <li>몽고디비는 테이블이 없어서 자유롭게 데이터를 넣을 수 있지만, 실수로 잘못된 자료형의 데이터를 넣거나, 다른 다큐먼트에는 없는 필드의 데이터를 넣을 수도 있다.</li> <li>몽구스는 데이터를 넣기 전 노드 서버 단에서 데이터를 한번 필터링 하는 역할을 해줌</li> <li>MySQL에 있는 JOIN 기능을 populate 라는 메서드로 어느 정도 보완. 관계가 있는 데이터를 쉽게 가져올 수 있습니다. 쿼리 한 번에 데이터를 합쳐서 가져오는 아니지만, 직접 작업하지 않아도 되서 편리.</li> <li>ES2015 프로미스 문법과 강력하고 가독성이 높은 쿼리 빌러를 지원하는 것도 장점.</li></ul> <h4 id="_8-6-1-몽고디비-연결하기"><a href="#_8-6-1-몽고디비-연결하기" class="header-anchor">#</a> 8.6.1 몽고디비 연결하기</h4> <ul><li>연결 주소 형식
<ul><li>mongodb://[username:password@]host[:port][/[database][?options]]</li> <li>[] 부분은 있어도 되고 없어도 됨을 의미</li></ul></li></ul> <h4 id="_8-6-2-스키마-정의하기"><a href="#_8-6-2-스키마-정의하기" class="header-anchor">#</a> 8.6.2 스키마 정의하기</h4> <ul><li>몽구스 스키마의 특이한 점은 String, Number, Date, Buffer, Boolean, Mixed, ObjectId, Array를 값으로 가질 수 있다는 점. 몽고디비의 자료형과 살짝 다릅니다. 편의를 위해 종류 수를 줄여두었음.</li></ul> <h5 id="컬렉션-이름-바꾸기"><a href="#컬렉션-이름-바꾸기" class="header-anchor">#</a> 컬렉션 이름 바꾸기</h5> <ul><li>몽구스는 model 메서드의 첫 번째 인자로 컬렉션 이름을 만듬. 첫 번째 인자가 User 이면 첫 글자를 소문자로 만든 뒤 복수형으로 바꿔서 users 컬렉션을 생성. 이런 강제 개명이 싫다면 세 번째 인자로 컬렉션 이름을 설정 가능.</li></ul> <h4 id="_8-6-3-쿼리-수행하기"><a href="#_8-6-3-쿼리-수행하기" class="header-anchor">#</a> 8.6.3 쿼리 수행하기</h4></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.0235138a.js" defer></script><script src="/TIL/assets/js/2.436ac5ee.js" defer></script><script src="/TIL/assets/js/28.4503ac6f.js" defer></script>
  </body>
</html>
