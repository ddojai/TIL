<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>자바 ORM 표준 JPA 프로그래밍 | TIL</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="book">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.d0582fc1.css" as="style"><link rel="preload" href="/TIL/assets/js/app.0235138a.js" as="script"><link rel="preload" href="/TIL/assets/js/2.436ac5ee.js" as="script"><link rel="preload" href="/TIL/assets/js/34.0290c947.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.29443ebd.js"><link rel="prefetch" href="/TIL/assets/js/11.61ffbab5.js"><link rel="prefetch" href="/TIL/assets/js/12.fd56b06e.js"><link rel="prefetch" href="/TIL/assets/js/13.6d6d801f.js"><link rel="prefetch" href="/TIL/assets/js/14.54ae511d.js"><link rel="prefetch" href="/TIL/assets/js/15.9326f428.js"><link rel="prefetch" href="/TIL/assets/js/16.59b11cce.js"><link rel="prefetch" href="/TIL/assets/js/17.106bf525.js"><link rel="prefetch" href="/TIL/assets/js/18.eaa5b975.js"><link rel="prefetch" href="/TIL/assets/js/19.f755930c.js"><link rel="prefetch" href="/TIL/assets/js/20.ac8b4f01.js"><link rel="prefetch" href="/TIL/assets/js/21.3bd5aaed.js"><link rel="prefetch" href="/TIL/assets/js/22.68cd951c.js"><link rel="prefetch" href="/TIL/assets/js/23.3feb04c0.js"><link rel="prefetch" href="/TIL/assets/js/24.779346bd.js"><link rel="prefetch" href="/TIL/assets/js/25.b59b52ba.js"><link rel="prefetch" href="/TIL/assets/js/26.c0c6c7ad.js"><link rel="prefetch" href="/TIL/assets/js/27.360eaa97.js"><link rel="prefetch" href="/TIL/assets/js/28.4503ac6f.js"><link rel="prefetch" href="/TIL/assets/js/29.64787674.js"><link rel="prefetch" href="/TIL/assets/js/3.401c3d8b.js"><link rel="prefetch" href="/TIL/assets/js/30.cef16292.js"><link rel="prefetch" href="/TIL/assets/js/31.a9247786.js"><link rel="prefetch" href="/TIL/assets/js/32.bcf80982.js"><link rel="prefetch" href="/TIL/assets/js/33.586aad8d.js"><link rel="prefetch" href="/TIL/assets/js/35.f6fc3347.js"><link rel="prefetch" href="/TIL/assets/js/36.21300ae3.js"><link rel="prefetch" href="/TIL/assets/js/37.5f281d3f.js"><link rel="prefetch" href="/TIL/assets/js/38.8dac9edd.js"><link rel="prefetch" href="/TIL/assets/js/39.3e10d640.js"><link rel="prefetch" href="/TIL/assets/js/4.1d6ef5fb.js"><link rel="prefetch" href="/TIL/assets/js/40.54550932.js"><link rel="prefetch" href="/TIL/assets/js/41.b64c16f9.js"><link rel="prefetch" href="/TIL/assets/js/42.6420dfe0.js"><link rel="prefetch" href="/TIL/assets/js/43.203ba36e.js"><link rel="prefetch" href="/TIL/assets/js/44.927e5bc7.js"><link rel="prefetch" href="/TIL/assets/js/45.60a68f17.js"><link rel="prefetch" href="/TIL/assets/js/46.fe97eba5.js"><link rel="prefetch" href="/TIL/assets/js/47.2a55a663.js"><link rel="prefetch" href="/TIL/assets/js/48.fac9b4eb.js"><link rel="prefetch" href="/TIL/assets/js/49.78bf5894.js"><link rel="prefetch" href="/TIL/assets/js/5.6616a67f.js"><link rel="prefetch" href="/TIL/assets/js/6.b00d925a.js"><link rel="prefetch" href="/TIL/assets/js/7.f88e4318.js"><link rel="prefetch" href="/TIL/assets/js/8.9e344053.js"><link rel="prefetch" href="/TIL/assets/js/9.0eb5db88.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.d0582fc1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><img src="https://avatars.githubusercontent.com/u/2128592?v=4" alt="TIL" class="logo"> <span class="site-name can-hide">TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/TIL/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/TIL/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>ENVIRONMENT</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/env/mac.html" class="sidebar-link">mac</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>PHP</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="content__default"><h1 id="코어-자바스크립트"><a href="#코어-자바스크립트" class="header-anchor">#</a> 코어 자바스크립트</h1> <h2 id="ch-01-데이터-타입"><a href="#ch-01-데이터-타입" class="header-anchor">#</a> CH 01.데이터 타입</h2> <h3 id="_01-데이터-타입의-종류"><a href="#_01-데이터-타입의-종류" class="header-anchor">#</a> 01. 데이터 타입의 종류</h3> <ul><li>primitive type (기본형, 원시형)
<ul><li>number</li> <li>string</li> <li>boolean</li> <li>null</li> <li>undefined</li> <li>Symbol (ES6)</li></ul></li> <li>reference type (참조형)
<ul><li>Object
<ul><li>Array</li> <li>Function</li> <li>Date</li> <li>RegExp</li> <li>Map, WeakMap (ES6)</li> <li>Set, WeakSet (ES6)</li></ul></li></ul></li></ul> <h3 id="_02-데이터-타입에-관한-배경지식"><a href="#_02-데이터-타입에-관한-배경지식" class="header-anchor">#</a> 02. 데이터 타입에 관한 배경지식</h3> <h4 id="_1-2-1-메모리와-데이터"><a href="#_1-2-1-메모리와-데이터" class="header-anchor">#</a> 1-2-1. 메모리와 데이터</h4> <ul><li>자바스크립트는 숫자의 경우 정수형인지 부동소수형인지를 구분하지 않고 8바이트를 확보합니다.
<ul><li>이 중 1비트는 부호, 11 비트는 지수부, 나머지 52비트는 가수부</li></ul></li> <li>모든 데이터는 바이트 단위의 식별자, 더 정확하게는 메모리 주솟값을 통해 서로 구분하고 연결할 수 있습니다.</li></ul> <h4 id="_1-2-2-식별자와-변수"><a href="#_1-2-2-식별자와-변수" class="header-anchor">#</a> 1-2-2. 식별자와 변수</h4> <ul><li>영어 단어 variable은 원래 '변할 수 있다'라는 형용사이지만 컴퓨터 용어로 쓸 때는 '변할 수 있는 무언가'라는 명사로 확장</li> <li>식별자는 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수 명입니다.</li></ul> <h3 id="_03-변수-선언과-데이터-할당"><a href="#_03-변수-선언과-데이터-할당" class="header-anchor">#</a> 03. 변수 선언과 데이터 할당</h3> <h4 id="_1-3-1-변수-선언"><a href="#_1-3-1-변수-선언" class="header-anchor">#</a> 1-3-1. 변수 선언</h4> <ul><li>메모리 공간의 이름(식별자)을 a라고 지정합니다</li> <li>사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 남긴 데이터를 반환</li></ul> <h4 id="_1-3-2-데이터-할당"><a href="#_1-3-2-데이터-할당" class="header-anchor">#</a> 1-3-2. 데이터 할당</h4> <ol><li>변수 영역에서 빈공간(@1003)을 확보</li> <li>확보한 공간의 식별자를 a로 지정</li> <li>데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장</li> <li>변수 영역에서 a라는 식별자를 검색한다(@1003)</li> <li>앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입</li></ol> <ul><li>효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장</li> <li>문자열 'abc'의 마지막에 'def'를 추가하라고 하면 컴퓨터는 'abcdef'라는 문자열을 새로 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결합니다.</li> <li>기존 데이터는 자신의 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터의 수거 대상이 됩니다.</li> <li>다른 예로 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황에서는 주소 공간만 사용하고 데이터 공간을 아낄 수 있다.</li></ul> <h3 id="_04-기본형-데이터와-참조형-데이터"><a href="#_04-기본형-데이터와-참조형-데이터" class="header-anchor">#</a> 04. 기본형 데이터와 참조형 데이터</h3> <h4 id="_1-4-1-불변값"><a href="#_1-4-1-불변값" class="header-anchor">#</a> 1-4-1. 불변값</h4> <ul><li>변수와 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리</li> <li>불변성 여부를 구분할 때의 변경 가능성의 대상은 데이터 영역의 메모리</li> <li>기본형 데이터는 모두 불변값</li></ul> <h4 id="_1-4-2-가변값"><a href="#_1-4-2-가변값" class="header-anchor">#</a> 1-4-2. 가변값</h4> <ul><li>참조형 데이터는 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용도 가능</li></ul> <ol><li>컴퓨터는 우선 변수 영역의 빈 공간(@1002)을 확보하고, 그 주소의 이름을 obj1로 지정</li> <li>임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹입니다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103 ~ ?)를 @5001에 저장합니다.</li> <li>@7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정합니다.</li> <li>데이터 영역에서 숫자 1을 검색합니다. 검색 결과가 없으므로 임의로 @5003에 저장하고, 이 주소를 @7103에 저장합니다. 문자열 'bbb' 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장합니다.</li></ol> <ul><li>기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점</li> <li>객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용</li> <li>데이터 영역에 저장된 값은 모두 불변값</li> <li>변수에는 다른 값을 얼마든지 대입할 수 있습니다. 바로 이 부분 때문에 흔히 참조형 데이터는 불변(immutable)하지 않다(가변값이다)라고 하는 것이다.</li> <li>참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당하는 경우를 일컬어 중첩 객체(nested object)라고 합니다.</li></ul> <h4 id="_1-4-3-변수-복사-비교"><a href="#_1-4-3-변수-복사-비교" class="header-anchor">#</a> 1-4-3. 변수 복사 비교</h4> <ul><li>변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일</li> <li>기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이</li> <li>참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립합니다.</li></ul> <h3 id="_05-불변-객체"><a href="#_05-불변-객체" class="header-anchor">#</a> 05. 불변 객체</h3> <h4 id="_1-5-1-불변-객체를-만드는-간단한-방법"><a href="#_1-5-1-불변-객체를-만드는-간단한-방법" class="header-anchor">#</a> 1-5-1. 불변 객체를 만드는 간단한 방법</h4> <ul><li>내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구를 활용
<ul><li>immutable.js, immer.js, immutability-helper 등의 라이브러리가 있음</li></ul></li></ul> <h4 id="_1-5-2-얕은-복사와-깊은-복사"><a href="#_1-5-2-얕은-복사와-깊은-복사" class="header-anchor">#</a> 1-5-2. 얕은 복사와 깊은 복사</h4> <ul><li>얕은 복사(shallow copy)는 바로 아래 단계의 값만 복사하는 방법</li> <li>깊은 복사(deep copy)는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법</li> <li>얕은 복사는 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주소값만 복사되어 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 되어 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다.</li></ul> <h3 id="_06-undefined와-null"><a href="#_06-undefined와-null" class="header-anchor">#</a> 06. undefined와 null</h3> <ul><li>자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환합니다.
<ol><li>값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때</li> <li>객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때</li> <li>return 문이 없거나 호출되지 않는 함수의 실행 결과</li></ol></li> <li>값으로서 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것.</li> <li>직접 undefined를 할당하지 않으면 혼란을 피할 수 있음.</li> <li>'비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null을 사용</li> <li>typeof null 이 object 인데 이것은 자바스크립트 자체 버그</li></ul> <h3 id="_07-정리"><a href="#_07-정리" class="header-anchor">#</a> 07. 정리</h3> <ul><li>자바스크립트 데이터 타입에는 크게 기본형과 참조형이 있음</li> <li>기본형은 불변값, 참조형은 가변값</li> <li>변수는 변경 가능한 데이터가 담길 수 있는 공간이고, 식별자는 그 변수의 이름</li> <li>참조형 데이터는 여러 개의 프로퍼티(변수)를 모은 '그룹'</li> <li>참조형 데이터를 가변값으로 여겨야 하는 상황에서 이를 불변값으로 사용 가능
<ul><li>내부 프로퍼티들을 일일이 복사(깊은 복사)</li> <li>라이브러리 사용</li></ul></li> <li>undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미</li> <li>null은 사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값</li> <li>사용자가 명시적으로 undefined를 대입하는 것은 지양하는 것이 좋음</li></ul> <h2 id="ch-02-실행-컨텍스트"><a href="#ch-02-실행-컨텍스트" class="header-anchor">#</a> CH 02.실행 컨텍스트</h2> <ul><li>실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체</li></ul> <h3 id="_01-실행-컨텍스트란"><a href="#_01-실행-컨텍스트란" class="header-anchor">#</a> 01. 실행 컨텍스트란?</h3> <ul><li>동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아 올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장.</li> <li>하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있습니다.</li> <li>자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것.</li> <li>실행 컨텍스트 객체에 저장되는 정보
<ul><li>VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.</li> <li>LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.</li> <li>ThisBinding: this 식별자가 바라봐야 할 대상 객체.</li></ul></li></ul> <h3 id="_02-variableenvironment"><a href="#_02-variableenvironment" class="header-anchor">#</a> 02. VariableEnvironment</h3> <ul><li>실헹 컨텍스트를 실행할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 이대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용</li> <li>내부는 environmentRecord와 outer-EnvironmentReference로 구성</li></ul> <h3 id="_03-leximalenvironment"><a href="#_03-leximalenvironment" class="header-anchor">#</a> 03. LeximalEnvironment</h3> <h4 id="_2-3-1-environmentrecord와-호이스팅"><a href="#_2-3-1-environmentrecord와-호이스팅" class="header-anchor">#</a> 2-3-1. environmentRecord와 호이스팅</h4> <ul><li>environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장</li> <li>컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당</li> <li>컨텍스트 내부 전체를 처음부터 끝까지 순서대로 수집</li> <li>참고
<ul><li>전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체, 즉 전역 객체를 활용. (브라우저의 window, Node.js의 global 객체 등)</li> <li>이들은 자바스크립트 내장 객체가 아닌 호스트 객체로 분류</li></ul></li> <li>엔진의 실제 동작 방식 대신에 '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각하더라도 코드를 해석하는 데는 문제될 것이 전혀 없음</li></ul> <h5 id="호이스팅-규칙"><a href="#호이스팅-규칙" class="header-anchor">#</a> 호이스팅 규칙</h5> <ul><li>environmedRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담김</li> <li>environmedRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없습니다.</li> <li>변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둡니다.</li></ul> <h5 id="함수-선언문과-함수-표현식"><a href="#함수-선언문과-함수-표현식" class="header-anchor">#</a> 함수 선언문과 함수 표현식</h5> <ul><li>함수 선언문은 function 정의부만 존재하고 별도의 할당 명령이 없는 것</li> <li>함수 표현식은 정의한 function을 별도의 변수에 할당하는 것</li> <li>협업을 위해서는 전역공간에 함수를 선언하거나 동명의 함수를 중복 선언하는 경우는 없어야 함</li></ul> <h4 id="_2-3-2-스코프-스코프-체인-outerenvironmentreference"><a href="#_2-3-2-스코프-스코프-체인-outerenvironmentreference" class="header-anchor">#</a> 2-3-2. 스코프, 스코프 체인, outerEnvironmentReference</h4> <ul><li>스코프란 식별자에 대한 유효범위</li> <li>ES5까지의 자바스크립트는 특이하게도 전역공간을 제외하면 오직 함수에 의해서만 스코프가 생성</li> <li>이러한'식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라 함</li> <li>이를 가능케 하는 것은 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference</li></ul> <h5 id="스코프-체인"><a href="#스코프-체인" class="header-anchor">#</a> 스코프 체인</h5> <ul><li>outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조</li> <li>각 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근 가능</li> <li>여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능</li></ul> <h5 id="전역번수와-지역변수"><a href="#전역번수와-지역변수" class="header-anchor">#</a> 전역번수와 지역변수</h5> <ul><li>전역 공간에서 선언한 변수는 전역변수</li> <li>함수 내부에서 선언한 변수는 지역변수</li></ul> <h3 id="_04-this"><a href="#_04-this" class="header-anchor">#</a> 04. this</h3> <ul><li>실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장.</li> <li>실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장.</li> <li>그밖에는 함수를 호출하는 방법에 따라 this에 저장되는 대상이 다름</li></ul> <h3 id="_05-정리"><a href="#_05-정리" class="header-anchor">#</a> 05. 정리</h3> <ul><li>살행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체.</li> <li>실행 컨텍스트는 전역 공간에서ㅓ 자동으로 생성되는 전역 컨텍스트와 eval 및 함수 실행에 의한 컨텍스트 등이 있음.</li> <li>실행 컨텍스트 객체는 활성화되는 시점에 VariableEnvironment, LexicalEnvironment, ThisBinding의 세 가지 정보를 수집</li> <li>싱행 컨텍스트를 생성시 VariableEnvironment와 LexicalEnvironment가 동일한 내용으로 구성되지만 LexicalEnvironment는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면 VariableEnvironment는 초기 상태를 유지</li> <li>VariableEnvironment와 LexicalEnvironment는 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집하는 environmentRecord와 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조하는 outerEnvironmentReference로 구성</li> <li>호이스팅은 코드 해석을 수월하게 하기 위해 environmentRecord의 수집 과정을 추상화한 개념</li> <li>실행 컨텍스트가 관여하는 코드 집단의 최상단으로 이들을 '끌어올린다'고 해석</li> <li>변수 선언과 값 할당이 동시에 이뤄진 문장은 '선언부'만을 호이스팅 하고, 할당 과정은 원래 자리에 남아있게 되는데, 여기서 함수 선언문과 함수 표현식의 차이가 발생</li> <li>스코프는 변수의 유효범위</li> <li>outerEnvironmentReference는 해당 함수가 선언된 위치의 LexicalEnvironment를 참조</li> <li>코드에서 어떤 변수에 접근하려고 하면 현재 컨텍스트의 LexicalEnvironment를 탐색해서 발견되면 그 값을 반환하고, 발견하지 못할 경우 다시 outerEnvironmentReference에 담긴 LexicalEnvironment를 탐색하는 과정을 거칩니다.</li> <li>전역 컨텍스트의 LexicalEnvironment까지 탐색해도 해당 변수를 찾이 못하면 undefined를 반환</li> <li>전역 컨텍스트의 LexicalEnvironment에 담긴 변수를 전역 변수라 함.</li> <li>그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수들은 모두 지역 변수</li> <li>안전한 코드 구성을 위해 가급적 전역변수의 사용은 최소화 팔요</li> <li>this에는 실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장.</li> <li>함수를 호출하는 방법에 따라 그 값이 달리지는데, 지정하지 않은 격우에는 전역 객체가 저장.</li></ul> <h2 id="ch-03-this"><a href="#ch-03-this" class="header-anchor">#</a> ch 03. this</h2> <ul><li>함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능</li></ul> <h3 id="_01-상황에-따라-달라지는-this"><a href="#_01-상황에-따라-달라지는-this" class="header-anchor">#</a> 01. 상황에 따라 달라지는 this</h3> <ul><li>this는 함수를 호출할 때 결정</li></ul> <h4 id="_3-1-1-전역-공간에서의-this"><a href="#_3-1-1-전역-공간에서의-this" class="header-anchor">#</a> 3-1-1. 전역 공간에서의 this</h4> <ul><li>전역 공간에서 this는 전역 객체를 가리킴</li> <li>개념상 전역 컨텍스트를 생헝하는 주체가 전역 객체</li> <li>브라우저에서 전역객체는 window, Node.js에서는 global</li> <li>전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다</li> <li>자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작</li> <li>특정 객체란 실행 컨텍스트의 LexicalEnvironment</li> <li>처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않음.</li> <li>var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보임</li></ul> <h4 id="_3-1-2-메서드로서-호출할-때-그-메서드-내부에서의-this"><a href="#_3-1-2-메서드로서-호출할-때-그-메서드-내부에서의-this" class="header-anchor">#</a> 3-1-2. 메서드로서 호출할 때 그 메서드 내부에서의 this</h4> <h5 id="함수-vs-메서드"><a href="#함수-vs-메서드" class="header-anchor">#</a> 함수 vs 메서드</h5> <ul><li>이 둘을 구분하는 유일한 차이는 독립성</li> <li>함수는 그 자체로 독립적인 기능을 수행, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행</li> <li>자바스크립트는 상황별로 this 키워드에 다른 값을 부여하게 함으로써 이를 구현</li> <li>객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작</li> <li>점 표기법이든 대괄호 표기법이든, 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그 외의 모든 경우에는 함수로 호출한 것</li></ul> <h5 id="메서드-내부에서의-this"><a href="#메서드-내부에서의-this" class="header-anchor">#</a> 메서드 내부에서의 this</h5> <ul><li>this에는 호출한 주체에 대한 정보가 담김</li> <li>어떤 함수를 메서드로서 호출하는 경우 호출 주체는 함수명(프로퍼티명) 앞의 객체</li></ul> <h4 id="_3-1-3-함수로서-호출할-때-그-함수-내부에서의-this"><a href="#_3-1-3-함수로서-호출할-때-그-함수-내부에서의-this" class="header-anchor">#</a> 3-1-3. 함수로서 호출할 때 그 함수 내부에서의 this</h4> <h5 id="함수-내부에서의-this"><a href="#함수-내부에서의-this" class="header-anchor">#</a> 함수 내부에서의 this</h5> <ul><li>어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않습니다.</li> <li>실행 컨텍스트를 활서화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라봄</li> <li>함수에서의 this는 전역 객체를 가리키는데 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적</li></ul> <h5 id="메서드의-내부함수에서의-this"><a href="#메서드의-내부함수에서의-this" class="header-anchor">#</a> 메서드의 내부함수에서의 this</h5> <ul><li>내부함수 역시 이를 함수로서 호출했는지 메서드로서 호출했는지만 파악하면 this의 값을 정확히 확인 가능</li> <li>this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건</li></ul> <h5 id="메서드의-내부-함수에서의-this를-우회하는-방법"><a href="#메서드의-내부-함수에서의-this를-우회하는-방법" class="header-anchor">#</a> 메서드의 내부 함수에서의 this를 우회하는 방법</h5> <ul><li>ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없지만 변수를 활용해서 우회 가능</li> <li>상위 스코프의 this를 저장해서 내부함수에서 활용하려는 수단으로 self를 가장 많이 사용</li></ul> <h5 id="this를-바인딩하지-않는-함수"><a href="#this를-바인딩하지-않는-함수" class="header-anchor">#</a> this를 바인딩하지 않는 함수</h5> <ul><li>ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입</li> <li>화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용</li> <li>내부함수를 화살표 함수로 바꾸면 우회법이 불필요</li> <li>그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정 가능</li></ul> <h4 id="_3-1-4-콜백-함수-호출-시-그-함수-내부에서의-this"><a href="#_3-1-4-콜백-함수-호출-시-그-함수-내부에서의-this" class="header-anchor">#</a> 3-1-4. 콜백 함수 호출 시 그 함수 내부에서의 this</h4> <ul><li>함수 A의 제어권을 다른 함수(또는 메소드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 함</li> <li>이때 함수 A는 함수 Bㅢ 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정</li> <li>콜백 함수도 함수이기 때문에 기본적으로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조</li> <li>콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정</li> <li>특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라봄</li></ul> <h4 id="_3-1-5-생성자-함수-내부에서의-this"><a href="#_3-1-5-생성자-함수-내부에서의-this" class="header-anchor">#</a> 3-1-5. 생성자 함수 내부에서의 this</h4> <ul><li>생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수</li> <li>객체지향 언어에서는 생성자를 클래스, 클래를 통해 만든 객체를 인스턴스라고 함</li> <li>프로그래밍적으로 '생성자'는 구체적인 인스턴스를 만들기 위한 일종의 틀</li> <li>자바스크립트는 함수에 생성자로서의 역할을 함께 부여</li> <li>new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작</li> <li>어떤 함수가 생성자 함수로서 호출될 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 됨</li> <li>생성자 함수를 호출(new 명령어와 함께 함수를 호출)하면 우선 생성자의 prototype 프로퍼티를 참조하는 __proto__라는 프로퍼티가 있는 객체(인스턴스)를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여</li></ul> <h3 id="_02-명시적으로-this를-바인딩하는-방법"><a href="#_02-명시적으로-this를-바인딩하는-방법" class="header-anchor">#</a> 02. 명시적으로 this를 바인딩하는 방법</h3> <ul><li>상황별로 this에 값이 바인딩 되는 규칙이 있지만 별도의 대상에 바인딩하는 방법도 있습니다.</li></ul> <h4 id="_3-2-1-call-메서드"><a href="#_3-2-1-call-메서드" class="header-anchor">#</a> 3-2-1. call 메서드</h4> <ul><li>call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하는 명령</li> <li>call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 함</li> <li>함수를 그냥 실행하면 this는 전역객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있음</li> <li>메서드에 대해서도 마찬가지로 객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정 가능</li></ul> <h4 id="_3-2-2-apply-메서드"><a href="#_3-2-2-apply-메서드" class="header-anchor">#</a> 3-2-2. apply 메서드</h4> <ul><li>apply 메서드는 call 메서드와 기능적으로 완전히 동일</li> <li>apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 점에서만 차이가 있음</li></ul> <h4 id="_3-2-3-call-apply-메서드의-활용"><a href="#_3-2-3-call-apply-메서드의-활용" class="header-anchor">#</a> 3-2-3. call/apply 메서드의 활용</h4> <ul><li>call/apply 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 훌륭한 방법이지만 오히려 이로 인해 this를 예측하기 어렵게 만들어 코드 해석을 방해</li> <li>그럼에도 ES5 이하의 환경에서는 마땅한 대안이 없어 실무에서 매우 광범위하게 활용</li></ul> <h5 id="유사배열객체에-배열-메서드로-적용"><a href="#유사배열객체에-배열-메서드로-적용" class="header-anchor">#</a> 유사배열객체에 배열 메서드로 적용</h5> <ul><li>객체에는 배열 메서드를 직접 적용 불가</li> <li>키가 0 또는 양의 정수인 프로퍼티가 존재하고 lenth 프로퍼티의 값이 0 또는 양의 정수인 객체, 즉 배열의 구조와 유사한 객체의 경우 call 또는 apply 메서드를 이용해 배열 메서드를 차용 가능</li> <li>배열처럼 인덱스와 length 프로퍼티를 지니는 문자열에 대해서도 마찬가지</li> <li>단, 문자열의 경우 length 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드는 에러를 던지며, concat처럼 대상이 반드시 배열이어야 하는 경우에는 에러가 나지 않지만 제대로 된 결과를 얻지 못함</li> <li>call/apply를 이용해 형변환하는 것은 'this를 원하는 값으로 지정해서 호출한다'라는 본래의 메서드의 의도와는 다소 동떨어진 활용법</li> <li>ES6에서는 유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 Array.from 메서드를 새로 도입</li></ul> <h5 id="생성자-내부에서-다른-생성자를-호출"><a href="#생성자-내부에서-다른-생성자를-호출" class="header-anchor">#</a> 생성자 내부에서 다른 생성자를 호출</h5> <ul><li>생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있음.</li></ul> <h5 id="여러-인수를-묶어-하나의-배열로-전달하고-싶을-때-apply-활용"><a href="#여러-인수를-묶어-하나의-배열로-전달하고-싶을-때-apply-활용" class="header-anchor">#</a> 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용</h5> <ul><li>여러 개의 인수를 받는 메서드에게 하나의 배열로 인수들을 전달하고 싶을 때 apply 메서드를 사용하면 좋음</li> <li>참고로 ES에서는 펼치기 연산자(spread operator)를 이용하면 더욱 간편</li></ul> <h4 id="_3-2-4-bind-메서드"><a href="#_3-2-4-bind-메서드" class="header-anchor">#</a> 3-2-4. bind 메서드</h4> <ul><li>bind 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드</li> <li>다시 새로운 함수를 호출할 때 인수를 넘기면 그 인수들은 기존 bind 메서드를 호출할 때 전달했던 인수들의 뒤에 이어서 등록</li></ul> <h5 id="name-프로퍼티"><a href="#name-프로퍼티" class="header-anchor">#</a> name 프로퍼티</h5> <ul><li>name 프로퍼티에 동사 bind의 수동태인 'bound'라는 접두어가 부음</li> <li>기존의 call이나 apply보다 코드 추적에 비교적 수월</li></ul> <h5 id="상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기"><a href="#상위-컨텍스트의-this를-내부함수나-콜백-함수에-전달하기" class="header-anchor">#</a> 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기</h5> <ul><li>메서드의 내부함수에서 메서드의 this를 그대로 바라보게 하기 위한 방법으로 self 등의 변수를 활용한 우회법을 소개했는데, call, apply 또는 bind 메서드를 이용하면 더 깔끔하게 처리 가능</li> <li>콜백 함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도 bind 메서드를 이용하면 this 값을 사용자의 입맛에 맞게 바꿀 수 있음.</li></ul> <h4 id="_3-2-5-화살표-함수의-예외사항"><a href="#_3-2-5-화살표-함수의-예외사항" class="header-anchor">#</a> 3-2-5. 화살표 함수의 예외사항</h4> <ul><li>ES6에 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외</li> <li>이 함수 내부에는 this가 아예 없으며, 접근하고자 하면 스코프 체인상 가장 가까운 this에 접근</li></ul> <h4 id="_3-2-6-별도이-인자로-this를-받는-경우-콜백-함수-내에서의-this"><a href="#_3-2-6-별도이-인자로-this를-받는-경우-콜백-함수-내에서의-this" class="header-anchor">#</a> 3-2-6. 별도이 인자로 this를 받는 경우(콜백 함수 내에서의 this)</h4> <ul><li>콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 있는 경우가 있음.</li> <li>이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경 가능</li> <li>이런 형태는 여러 내부 요소에 대해 같은 동작을 반복 수행해야 하는 배열 메서드에 많음</li> <li>ES6에서 새로 등장한 Set, Map 등의 메서드에도 일부 존재</li></ul> <h3 id="_03-정리"><a href="#_03-정리" class="header-anchor">#</a> 03. 정리</h3> <ul><li>다음 규칙은 명시적 this 바인딩이 없는 한 늘 성립
<ul><li>전역 공간에서의 this는 전역객체를 참조</li> <li>어떤 함수를 메서드로 호출한 경우 this는 메서드 호출 주체를 참조</li> <li>어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조. 메서드의 내부함수도 동일</li> <li>콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역객체를 참조</li> <li>생성자 함수에서의 this는 생성될 인스턴스를 참조</li></ul></li> <li>다음은 명시적 this 바인딩입니다. 위 규칙에 부합하지 않는 경우에는 다음 내용을 바탕으로 this를 예측
<ul><li>call, apply 메서드는 this를 명시적으로 지정하면서 함수 또는 메서드를 호출</li> <li>bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만듬</li> <li>요소를 순회하면서 콜백 함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 함</li></ul></li></ul> <h2 id="ch04-콜백-함수"><a href="#ch04-콜백-함수" class="header-anchor">#</a> ch04. 콜백 함수</h2> <h3 id="_01-콜백-함수란"><a href="#_01-콜백-함수란" class="header-anchor">#</a> 01. 콜백 함수란?</h3> <ul><li>콜백 함수는 다른 코드의 인자로 넘겨주는 함수</li> <li>콜백 함수는 제어권과 관련</li></ul> <h3 id="_02-제어권"><a href="#_02-제어권" class="header-anchor">#</a> 02. 제어권</h3> <h4 id="_4-2-1-호출-시점"><a href="#_4-2-1-호출-시점" class="header-anchor">#</a> 4-2-1. 호출 시점</h4> <ul><li>콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가짐</li></ul> <h4 id="_4-2-2-인자"><a href="#_4-2-2-인자" class="header-anchor">#</a> 4-2-2. 인자</h4> <ul><li>컴퓨터는 순서에 의해서만 각각의 인자를 구분하고 인식</li> <li>콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가짐</li></ul> <h4 id="_4-2-3-this"><a href="#_4-2-3-this" class="header-anchor">#</a> 4-2-3. this</h4> <h3 id="_03-콜백-함수는-함수다"><a href="#_03-콜백-함수는-함수다" class="header-anchor">#</a> 03. 콜백 함수는 함수다</h3> <h1 id="출처"><a href="#출처" class="header-anchor">#</a> 출처</h1> <ul><li>코어 자바스크립트 (핵심 개념과 동작 원리로 이해하는 자바스크립트 프로그래밍)</li> <li>정재남 저, 위키북스</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.0235138a.js" defer></script><script src="/TIL/assets/js/2.436ac5ee.js" defer></script><script src="/TIL/assets/js/34.0290c947.js" defer></script>
  </body>
</html>
