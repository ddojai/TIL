(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{365:function(t,a,r){"use strict";r.r(a);var v=r(45),l=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"다이나믹-프로그래밍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#다이나믹-프로그래밍"}},[t._v("#")]),t._v(" 다이나믹 프로그래밍")]),t._v(" "),r("ul",[r("li",[t._v("큰 문제를 작은 문제로 나눠서 푸는 알고리즘")]),t._v(" "),r("li",[t._v("Dynamic Programming의 다이나믹은 아무 의미가 없다.")])]),t._v(" "),r("h2",{attrs:{id:"두가지-속성을-만족해야-다이나믹-프로그래밍-풀수-있다"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#두가지-속성을-만족해야-다이나믹-프로그래밍-풀수-있다"}},[t._v("#")]),t._v(" 두가지 속성을 만족해야 다이나믹 프로그래밍 풀수 있다.")]),t._v(" "),r("ul",[r("li",[t._v("부분 문제가 겹침 (Overlapping Subproblem)")]),t._v(" "),r("li",[t._v("최적 부분 구조")])]),t._v(" "),r("h2",{attrs:{id:"다이나믹을-푸는-두가지-방법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#다이나믹을-푸는-두가지-방법"}},[t._v("#")]),t._v(" 다이나믹을 푸는 두가지 방법")]),t._v(" "),r("ul",[r("li",[t._v("Top-down\n"),r("ul",[r("li",[t._v("재귀함수 사용")])])]),t._v(" "),r("li",[t._v("Bottom-up")])]),t._v(" "),r("h3",{attrs:{id:"bottom-up"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bottom-up"}},[t._v("#")]),t._v(" Bottom-up")]),t._v(" "),r("ol",[r("li",[t._v("문제의 크기가 작은 문제부터 차례대로 푼다.")]),t._v(" "),r("li",[t._v("문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.")]),t._v(" "),r("li",[t._v("작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.")]),t._v(" "),r("li",[t._v("그러다보면, 언젠가 풀어야 하는 문제를 풀 수 있다.")])])])}),[],!1,null,null,null);a.default=l.exports}}]);